<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Ömer Özkan</title>
    <link>https://omerozkan.net/etiket/java/</link>
    <description>Recent content in Java on Ömer Özkan</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>tr</language>
    <lastBuildDate>Fri, 03 Jun 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://omerozkan.net/etiket/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Java 8 Optional ve null dönebilen metotlar</title>
      <link>https://omerozkan.net/java-8-optional/</link>
      <pubDate>Fri, 03 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://omerozkan.net/java-8-optional/</guid>
      <description>&lt;p&gt;Merhabalar, bu yazıda sizlere Java 8 ile beraber gelen Optional sınıfından bahsedeceğim. Bu yazı ile birlikte Java
programlama dili ve teknolojileri konusunda ufak bilgiler paylaşmaya devam edeceğim. Umarım faydalı olur.&lt;/p&gt;

&lt;p&gt;Optional sınıfının kullanımına bir örnek vererek anlatacağım. Doğrudan anlatabilecek kadar basit bir sınıf olmasına rağmen
örnek üzerinden gitmenin daha kalıcı olduğunu düşünüyorum. Örneğimizde bir UserRepository sınıfı tasarlayacağız.
Interface&amp;rsquo;imiz şu şekilde:&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0ef7a9c175d40cdbea57ea72de25140e.js?file=userRepository1.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;UserRepository interface&amp;rsquo;inde &lt;code&gt;getByUsername()&lt;/code&gt; metodunun tanımlandığını görüyoruz. Adından da anlaşılacağı üzere kullanıcı
adı ile veritabanında kayıtlı bir kullanıcıyı bulmak istiyoruz. Basitçe aşağıdaki implementasyonu yapabiliriz.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0ef7a9c175d40cdbea57ea72de25140e.js?file=userRepositoryImpl1.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Herhangi bir persistent api kullanarak kullanıcı listesini aldık. Eğer liste boş dönerse girdiğimiz kullanıcı adına sahip
bir kullanıcı olmadığı anlamına geldiğinden &lt;code&gt;null&lt;/code&gt; object döndük. Eğer kullanıcı varsa listenin ilk elemanını dönüyoruz.
Kullandığınız api&amp;rsquo;nin ne olduğunun bir önemi yok. Bundan farklı bir implementasyonda olabilirdi. Burda dikkat etmemiz gereken
eğer veritabanında kullanıcı yoksa ne döneceğimiz. Bu tasarımda &lt;code&gt;null&lt;/code&gt; dönmüş olduk.&lt;/p&gt;

&lt;p&gt;Başlangıçta tasarım kusursuz görünse de &lt;code&gt;null&lt;/code&gt; dönmenin dezavantajları var. Bu sınıfı kullanan istemciye bir sorumluluk yükledik.
İstemci kullanıcıyı sorguladıktan sonra ayrıca bir de &lt;code&gt;null&lt;/code&gt;dönüp dönmediğini kontrol etmek zorunda. Aksi takdirde
NullPointerException&amp;rsquo;a sebep olur. Ayrıca bu aslında bir implementasyon detayı. İstemci açısından interface&amp;rsquo;e baktığınızda
aslında &lt;code&gt;null&lt;/code&gt; bir değer bekleyemeyiz. Basitçe bir metot var ve kullanıcı adı verip kullanıcı nesnesi alıyoruz. Yani interface
de &lt;code&gt;null&lt;/code&gt; obje gelebileceğine dair herhangi bir tanımlama yok. Javadoc veya yorum satırı mı geldi aklınıza? Burdaki javadoc
veya yorum satırı kötü koda sebep olur. Ayrıca kod açısından yine istemciyi bağlayan birşey yok. Bir diğer sorun ise null
dönülmesi bir implementasyon detayı. İmplementasyon yüzünden defensif programlama yapmak zorunda kalıyoruz.&lt;/p&gt;

&lt;p&gt;Burdaki durumda aslında kullanıcı nesnesinin &lt;code&gt;null&lt;/code&gt; gelebileceğini tahmin edebiliriz. Mantıken baktığınızda kullanıcı
veritabanında yoksa ne olur diye düşündüğünüzde &lt;code&gt;null&lt;/code&gt; dönebileceğini anlayabilirsiniz.
Fakat her durumda bu kadar basit bir durumda olmayabilir. Daha karmaşık bir implementasyonda istemci olarak bunu görmek
daha zordur. &lt;code&gt;null&lt;/code&gt; dönmek yerine exception kullanarak bir tasarım yapabiliriz:&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0ef7a9c175d40cdbea57ea72de25140e.js?file=userRepositoryImpl2.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;interface&amp;rsquo;i de şu şekilde değiştiriyoruz:&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0ef7a9c175d40cdbea57ea72de25140e.js?file=userRepository2.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Bu implementasyon yukarıda bahsettiğim sorunu çözüyor. Burada basit bir şekilde kullanıcı yoksa UserNotFoundException&amp;rsquo;u
fırlattık. Ayrıca checked exception olduğundan istemci bu metodu çağırırken exception&amp;rsquo;u handle etmek zorunda veya bir üst
katmana bırakabilir. Sonuç olarak implementasyona bakmadan interface bize exception fırlatabileceğini tanımlar.&lt;/p&gt;

&lt;p&gt;Bu tasarımın da yine dezavantajları var. İstemci taraf ya bir try-catch bloğu yazmak zorunda. Yani exception mekanizmasını
bir istisna durumu için değil normal akışın bir parçası olarak kullandık. Burada örneğin veritabanı bağlantısı kesilirse
exception atabilirdik veya istemci geçersiz bir kullanıcı adı gönderdiğinde IllegalArgumentException gibi bir exception
fırlatabilirdik. Fakat burdaki durum ne istemciye bağlı bir input hatası ne de beklenmeyen bir durum. O yüzden bu tarz
yapılarda Exception kullanmamalıyız.&lt;/p&gt;

&lt;p&gt;Çözüm olarak yine ilk tasarımımıza dönüp User entity&amp;rsquo;si dönmek yerine bir Result objesi dönebiliriz.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0ef7a9c175d40cdbea57ea72de25140e.js?file=userRepositoryImpl3.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;User entity&amp;rsquo;sini doğrudan dönmek yerine araya başka bir sınıf yerleştirerek ilk durumdaki sorunu çözmüş oluyoruz. Artık kullanıcının
veritabanında olmayacağını daha net bir şekilde ifade ettik. Bu tür Result sınıflarını immutable tanımlarsak daha iyi bir
tasarım yapmış oluruz. Constructor&amp;rsquo;lara isim veremediğimiz için burada static metod kullanmayı tercih ettim. UserResult sınıfı&amp;rsquo;da aşağıdaki gibi.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0ef7a9c175d40cdbea57ea72de25140e.js?file=userResult.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;İstemci taraf doesUserExist() metodu ile kontrol edip gereken işlemi yapabilir. Bu şekilde tasarımımız daha stabil oldu.
Àyrıca bunun büyük bir proje olacağını düşünürsek UserResult sınıfını daha generic olarak tasarlayabiliriz.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0ef7a9c175d40cdbea57ea72de25140e.js?file=entityResult.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;UserRepositoryImpl sınıfımızı da düzenleyelim.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0ef7a9c175d40cdbea57ea72de25140e.js?file=userRepositoryImpl4.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;EntityResult gibi result objeleri farklı implementasyonlar da içerebilir. Burda &lt;code&gt;null&lt;/code&gt;dönme problemini için kullandık.
Özellikle katmanlar arası iletişim bu şekilde yapılmalıdır.&lt;/p&gt;

&lt;p&gt;Java7 ile geliştirme yapsaydık eğer muhtemelen bu şekilde geliştirme yapacağız. Fakat Java 8 de bunun için &lt;code&gt;java.util&lt;/code&gt;
paketinin içerisinde &lt;code&gt;Optional&lt;/code&gt; diye bir sınıf eklendi. Kendi EntityResult gibi sınıflar yazmak yerine null dönebilen
metodlar için return type&amp;rsquo;ı Optional olarak tanımlayabiliriz.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0ef7a9c175d40cdbea57ea72de25140e.js?file=userRepositoryImpl5.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Optional yine tasarladığımız EntityResult gibi generic ve immutable bir sınıf. Yine &lt;code&gt;Optional.empty()&lt;/code&gt; aynı şekilde boş bir result dönüyor.
&lt;code&gt;null&lt;/code&gt; dönebilen yerlerde bunu kullanmalıyız. &lt;code&gt;Optional.of()&lt;/code&gt; metodunu da kullanırken dikkatli olmak gerekiyor. Eğer parametre
olarak verdiğiniz objenin değeri &lt;code&gt;null&lt;/code&gt; ise NullPointerException alırsınız. Eğer bir nesne &lt;code&gt;null&lt;/code&gt; olabilirse `Optional.ofNullable
metodunu kullanın. Diğer metodlarına da kısaca değinirsem:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;isPresent()&lt;/strong&gt; : eğer empty ise false diğer durumda true döner. İlk tasarımımızdaki null kontrolü yerine kullanılabilir.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;get()&lt;/strong&gt; : Empty olmayan durumlarda Optional içerisinde tanımlanan nesneyi döner. Mutlaka get den önce &lt;code&gt;isPresent()&lt;/code&gt; ile kontrol edilmesi
gerekiyor. Aksi takdirde değer empty ise NoSuchElementException alırsınız.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;orElse(T value)&lt;/strong&gt; : Eğer varsayılan bir değeriniz varsa kullanabilirsiniz. empty ise verdiğiniz değeri, değilse tanımlanan
değeri döner. Örneğin &lt;code&gt;null&lt;/code&gt; almak istiyorsanız &lt;code&gt;orElse(null)&lt;/code&gt; şeklinde nesneyi alabilirsiniz.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bunun gibi birçok metodu var. Aynı zamanda fonksiyonel özellikler de taşıyor. Java 8 ile beraber gelmesi bir raslantı değil :)
Dikkat etmeniz gereken başlangıçta metodları kullanırken mutlaka javadoc ile inceleyin. &lt;code&gt;get()&lt;/code&gt; metodunda olduğu gibi
exception alabilirsiniz. Ayrıca eğer Java 8 de Stream Api ile tanıştıysanız muhtemelen Optional sınıfını kullanmışsınızdır.
Stream Api&amp;rsquo;de oldukça fazla kullanılır. Primitive tipler için de &lt;code&gt;OptionalInt&lt;/code&gt;, &lt;code&gt;OptionalDouble&lt;/code&gt; gibi sınıfları da kullanabilirsiniz.&lt;/p&gt;

&lt;p&gt;Bu yazımda örnek bir tasarım ile Optional sınıfını anlatmaya çalıştım. Umarım faydalı olmuştur.&lt;/p&gt;

&lt;p&gt;Bir sonraki yazıda görüşmek üzere&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AB 15 Java 101 Kursu</title>
      <link>https://omerozkan.net/akademik-bilisim-15-java-101-kursu/</link>
      <pubDate>Tue, 30 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://omerozkan.net/akademik-bilisim-15-java-101-kursu/</guid>
      <description>

&lt;p&gt;Her yıl farklı bir üniversitede gerçekleşen Akademik Bilişim etkinliğine bu yıl Eskişehir Anadolu Üniversitesi ev sahipliği yapıyor.
Etkinlik 31 Ocak – 6 Şubat tarihleri arasında düzenlenecek. Konferans öncesi kurslar ise 31 Ocak – 3 Şubat arasında&amp;hellip;&lt;/p&gt;

&lt;p&gt;Bu yıl Akademik Bilişim&amp;rsquo;de Java 101 başlıklı Java&amp;rsquo;ya başlangıç yapmak isteyenler için kurs vereceğim. Katılım tamamen ücretsizdir.
Katılımcılar isterlerse KYK&amp;rsquo;da konaklayabilirler.&lt;/p&gt;

&lt;h3 id=&#34;hedef-kitle:9a905544edc0e3221aa5eb3d7e338cbf&#34;&gt;Hedef Kitle&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Temel algoritma, veri yapıları ve temel düzeyde nesne yönelimli programlama bilgisi olan,&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Başka bir programlama dilini bilen ve Java&amp;rsquo;ya başlangıç yapmak isteyen,&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Uzun zaman önce Java ile tanışmış fakat ilerleyememiş, temiz ve hızlı bir başlangıç yapmak isteyenler kişiler için hedeflenmiştir.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Kurs sonunda katılımcılar nesne yönelimli programlama (Object oriented programming) öğrenip,
Java ile ilgili teknolojilerde kendilerini geliştirebilmek için temel oluşturacak bilgi birikimine sahip olacaktır.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;katılımcılardan-istenenler:9a905544edc0e3221aa5eb3d7e338cbf&#34;&gt;Katılımcılardan İstenenler&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Herhangi bir linux dağıtımı yüklü dizüstü bilgisayarını getirmesi (Sanal makine tercih edilmemelidir.
Mümkünse OpenSuse, Ubuntu veya Fedora dağıtımlardan biri tercih edilmelidir )&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sistemlerine OpenJDK 7(veya üzeri) yüklemeleri&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Eclipse Luna (veya bir önceki sürümü Kepler) yüklemeleri gerekmektedir.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Not: Kurs sırasında herhangi bir yükleme işlemi yapılmayacaktır. O yüzden mutlaka yazılımların yüklü olması gerekmektedir.
Yazılım yüklemeleri için gereken döküman katılımcılara özel olarak eposta gönderilecektir.&lt;/p&gt;

&lt;h3 id=&#34;kontenjan-ve-kursiyer-seçimi:9a905544edc0e3221aa5eb3d7e338cbf&#34;&gt;Kontenjan ve Kursiyer Seçimi&lt;/h3&gt;

&lt;p&gt;Katılımcı sayısı 30 ile sınırlandırılmıştır. Başvuru sayısı fazla olması halinde adaylara 3 gün içerisinde doldurması gereken anket gönderilecektir.
Cevaplanan anketler sonucunda kursa uygun olan katılımcılar seçilecektir.&lt;/p&gt;

&lt;h3 id=&#34;konular:9a905544edc0e3221aa5eb3d7e338cbf&#34;&gt;Konular&lt;/h3&gt;

&lt;h4 id=&#34;1-gün:9a905544edc0e3221aa5eb3d7e338cbf&#34;&gt;1. Gün&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;JDK, JRE, JVM, Java Versiyonları&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java ile İlk Program&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Veri Tipleri, Operatörler, String&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Döngü ve Koşul&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sınıflar, Nesneler&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Construction&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Nesne Yönelimli Programlamaya Giriş&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Kapsülleme (Encapsulation)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Kalıtım (Inheritance)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;2-gün:9a905544edc0e3221aa5eb3d7e338cbf&#34;&gt;2. Gün&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Polimorfizm&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Soyutlama (Abstraction)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Casting&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Interface &amp;amp; Abstract Sınıflar&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Statik ve Final&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;3-gün:9a905544edc0e3221aa5eb3d7e338cbf&#34;&gt;3. Gün&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Exception Handling (Checked &amp;amp; Unchecked)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Diziler (Array)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Generic&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-gün:9a905544edc0e3221aa5eb3d7e338cbf&#34;&gt;4. Gün&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Collections (List, Set, Map, Iteration)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Enumeration&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mutable &amp;amp; Immutable&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Inner Class&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;String &amp;amp; StringBuilder&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SOLID&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kursa kayıt olmak için 1 Ocak 2015 tarihinden itibaren &lt;a href=&#34;http://ab2015.anadolu.edu.tr/&#34;&gt;http://ab2015.anadolu.edu.tr/&lt;/a&gt; adresinden yapabilirsiniz.
Kurs ile ilgili sorularınızı eposta ile sorabilirsiniz.&lt;/p&gt;

&lt;h3 id=&#34;diğer-kurslar:9a905544edc0e3221aa5eb3d7e338cbf&#34;&gt;Diğer Kurslar&lt;/h3&gt;

&lt;p&gt;Akademik Bilişim&amp;rsquo;de 40&amp;rsquo;a yakın kurs düzenlenecektir.
Kurslarla ilgili detaylı bilgiyi &lt;a href=&#34;http://ab.org.tr/ab15/kurs.html&#34;&gt;http://ab.org.tr/ab15/kurs.html&lt;/a&gt; adresinden edinebilirsiniz.&lt;/p&gt;

&lt;p&gt;Eskişehir&amp;rsquo;de görüşmek üzere&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bir Proje Hikayesi: Vipera</title>
      <link>https://omerozkan.net/bir-proje-hikayesi-vipera/</link>
      <pubDate>Wed, 24 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://omerozkan.net/bir-proje-hikayesi-vipera/</guid>
      <description>

&lt;p&gt;Öncelikle Vipera&amp;rsquo;nın ne olduğundan bahsedeyim. Vipera, bir sağlık sistemidir.
Çeşitli tıbbi cihazlar ile üretilen sağlık verilerini bir API üzerinden sisteme girilmesini sağlar.
Girilen bu verileri hekimlere sunarak hekimlerin hastalar hakkında karar vermesinde yardımcı olur.
Bir karar destek sistemidir. Hekimler kendi panellerinden grafikler üreterek hastanın sağlık durumunu takip eder.
Vipera, tanımlanan acil durum kuralları sayesinde de istenilen bildirim yöntemi ile (SMS ve Android Push Bildirimi halihazırda çalışmaktadır)
hekimlere bildirim gönderir.&lt;/p&gt;

&lt;p&gt;Aslında hedefim Vipera&amp;rsquo;nın hekimin yerine karar vermesini sağlamak yani bir uzman sistem oluşturmaktı.
Fakat bunu yapabilmek oldukça zor ve maliyetli bir işti.
O yüzden üzerinde yapay zeka yöntemlerinin uygulanabileceği verileri öncelikle saklamak gerektiğine karar verdim.&lt;/p&gt;

&lt;h3 id=&#34;teknik-hedef:76ab7a0392d682cc69cc876ca4838d28&#34;&gt;Teknik Hedef&lt;/h3&gt;

&lt;p&gt;Projenin bir de teknik bir hedefi vardı.
Java teknolojileri ile geliştirilmiş tamamen özgür teknolojilere sahip, esnek ve katmanlı bir mimariye sahip bir proje geliştirmekti.
Öğrendiğim yazılım araçlarını da etkin kullanmayı da hedeflemiştim.&lt;br /&gt;
Bitirme projesini bu şekilde yapmayı istedim. Proje konusunu ise danışmanım belirledi.&lt;/p&gt;

&lt;p&gt;Proje için Spring&amp;rsquo;i tercih ettim. Bunun asıl sebebi Spring&amp;rsquo;i öğrenmek istememdi.
Aynı zamanda Spring ile geliştireceğim proje Lightweight bir proje olacaktı.
Bununla birlikte gösterim katmanında JSF ve Primefaces, veri katmanında ise JPA&amp;rsquo;nın Hibernate implementasyonunu tercih ettim.
Defacto olan maven ve diğer araçları da kullandım.
Veritabanı olarak gömülü bir veritabanı yönetim sistemi olan HSQLDB&amp;rsquo;yi, asıl veritabanı yönetim sistemi  tercihim ise PostgreSQL oldu.
Veritabanı bağımsız olduğu için herhangi bir RDBMS kullanabilirdim.&lt;/p&gt;

&lt;h3 id=&#34;vipera:76ab7a0392d682cc69cc876ca4838d28&#34;&gt;Vipera?&lt;/h3&gt;

&lt;p&gt;Neden &amp;ldquo;Vipera&amp;rdquo; adını verdiğimi merak edenleriniz olabilir. Vipera, latince Engerek yılanı cinsi anlamına gelir.
Biyolojik bir isimdir. Sağlık ile ilgili bir proje geliştirdiğimden yılanların latince isimlerinden birini verebileceğimi düşündüm.
&amp;ldquo;Vipera&amp;rdquo; adını görünce proje adını belirledim.&lt;/p&gt;

&lt;h3 id=&#34;geliştirme-süreci:76ab7a0392d682cc69cc876ca4838d28&#34;&gt;Geliştirme Süreci&lt;/h3&gt;

&lt;p&gt;Okul dönemin uzun bir zamanında yarı zamanlı olarak çalıştığım için projeye zaman ayırmam mümkün olmadı.
İlk dönem sonunda sadece giriş ekranını kodlayabilmiştim. Bahar döneminin sonuna projenin bitmesi gerekiyordu.
Projeye başlarken kullanıcı hikayeleri ve görevler listesi oluşturdum. Daha sonra bunları önceliklendirdim.
Daha sonra kullanıcı hikayelerinin implementasyonuna başladım. Katmanlı mimari oluşturmak pek zor olmasa da
birçok teknolojiyi bir arada kullanmak başlangıçta bazı problemlere sebep oldu.
Başlangıçta test güdümlü geliştirsem de zaman ve projenin birçok kısmı basit ve net çözümler olduğundan
test güdümlü geliştirmeyi bıraktım. Fakat birçok yerde temiz kod yazmaya çalıştım.
%100 e yakın dökümantasyon yazdım.&lt;/p&gt;

&lt;h3 id=&#34;tubitak-yarışması:76ab7a0392d682cc69cc876ca4838d28&#34;&gt;Tubitak Yarışması&lt;/h3&gt;

&lt;p&gt;Zaman darlığında projeyi tamamlayamayacağımı düşünürken danışmanım
TUBİTAK tarafından düzenlenen Yazılım Projeleri Yarışması&amp;rsquo;na da katılmamı istedi.
Ben birçok kez katılmamayı düşünürken başvuru tarihinin sonuna yakın bir gecemi harcayarak ilgili belgeleri
hazırladım ve yarışmaya başvurdum.&lt;/p&gt;

&lt;p&gt;Yarışma için projenin yetişmeyeceğine kesin karar vermişken bir taraftan mezun olabilmek için sınavları geçmem gerekiyordu.
Ayrıca Vipera, bitirme projesi olduğundan bu dersi de geçmem gerekiyordu.
Projenin TUBİTAK&amp;rsquo;a teslimine 2 hafta kalmıştı.
O iki hafta sonunda finaller, ödevler, tez hazırlama gibi şeylerle karşılaşacağımdan kalan zamanım sadece 2 haftaydı.
Yarışma ile kendimi motive ederek projeyi tamamlamaya karar verdim.
Vizelerin yorgunluğunu henüz atamamışken gece gündüz projeyi kodlamaya devam ettim.
Son günde projeyi tamamladım fakat yarışma için video ve rapor hazırlamak gerekiyordu.
Video&amp;rsquo;yu montajlayıp izleyemeden TUBİTAK&amp;rsquo;a gönderdim. Rapor ise çok kötü haldeydi.
Elimden gelen bu kadar diyerek kötü internet bağlantısına ve verilen süreyi aşmama rağmen projeyi teslim etmeyi başardım.
Halen videoyu izleyip kendime gülüyorum :)&lt;/p&gt;

&lt;h3 id=&#34;bir-yarışma-hikayesi:76ab7a0392d682cc69cc876ca4838d28&#34;&gt;Bir Yarışma Hikayesi&lt;/h3&gt;

&lt;p&gt;Bitirme projesinin sunumundan bir gün önce final sergisine çağrıldığımı öğrendim. Final sergisine 1 hafta vardı.
Finallerin yorgunluğunu yine atamamışken bu sefer tekrar girişip bildirim sistemini geliştirdim.
Ayrıca afiş tasarımı vs. yaklaşık iki günümü almıştı.
Daha önce android e bulaşmaktan hep kaçmış biri olarak ilk defa bir android uygulaması geliştirdim ve
Vipera&amp;rsquo;nın bildirim sisteminin istemci tarafını yazdım.&lt;/p&gt;

&lt;p&gt;Yarışma açık kaynak kodlu uygulamalar kategorisinde yarışıyordum.
Bu kategorideki projeler, diğer kategorilere ve yarışmalara göre daha düşük kalıyordu.
Teknik  ve açık kaynak felsefesi açısından değerlendirildiğinde benim proje diğer projelerden üstündü.
Sunum için bize yaklaşık 7dk süre verildi. 45dklık bir semineri 75dk&amp;rsquo;da verebilen biri için oldukça kısa bir süreydi.
Üzerinde zaman harcayarak bu sürede sunumu tamamlamayı başardım. Sunumun sadece juriye yapılması,
serginin değerlendirilmemesi gibi yarışma birçok açıdan kalitesizdi.
Sunumu merak edenler yazının sonundaki slideshare sunumundan inceleyebilirler.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;25 Haziran&amp;rsquo;da yapılan ödül töreninde sonuçlar açıklandı ve Vipera üçüncü sırada yer aldı.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;teknik-açıdan-sonuçlar:76ab7a0392d682cc69cc876ca4838d28&#34;&gt;Teknik Açıdan Sonuçlar&lt;/h3&gt;

&lt;p&gt;Vipera, geliştirmiş olduğum ilk proje olması sebebi ile benim için önemli bir yere sahip.
Yarışmada ödül almasından daha çok böyle bir projeyi kısa sürede geliştirebilmek benim için oldukça büyük bir öneme sahip.
Esnek bir yapıda geliştirme yaptığımdan dolayı yeni öğreneceğim Java teknolojilerini de bu proje üzerinde deneme şansım olacak.
Yine benim için en önemli avantajı, hatalarımı görmem oldu. Gördüğüm başlıca eksiklikler şöyle:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Gösterim katmanındaki Controller ile işletme katmanının görevlerini karıştırmak,&lt;/li&gt;
&lt;li&gt;LOG yazmak konusunda nerdeyse hiç birşey bilmiyor olmam,&lt;/li&gt;
&lt;li&gt;Nerede test yazılması ve nerede yazılmaması gerektiği konusunda eksiklikler,&lt;/li&gt;
&lt;li&gt;Tasarım desenleri,&lt;/li&gt;
&lt;li&gt;Temiz kod!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Böyle bir projeyi geliştirmek zor olsa da beni motive ettiğini ve bugüne kadarki yazılım çalışmalarımın meyvesini aldığımı söyleyebilirim.&lt;/p&gt;

&lt;p&gt;TUBİTAK yarışmasına katılmayı düşünenler için de en önemli tavsiyem mutlaka bilimsel bir proje ile başvurulması.
Jüri, projenin bilimsel olmasına herşeyden daha çok önem veriyor.&lt;/p&gt;

&lt;h3 id=&#34;güncelleme:76ab7a0392d682cc69cc876ca4838d28&#34;&gt;Güncelleme&lt;/h3&gt;

&lt;p&gt;Bu yazının bu kısmını 7 Mart 2016&amp;rsquo;da yazıyorum. Projenin üzerinden nerdeyse 2 yıl geçmiş. Vipera benim üniversitede
öğrenmek istediğim konuları öğrendiğimin bir göstergesi oldu. Yukarda da bahsettiğim proje hatalarla dolu. Ne de olsa
o zamanlar mezun bile değildim. Projeyi öğrenme amacı ile inceleyecek olan arkadaşlar dikkatli olsunlar.&lt;/p&gt;

&lt;p&gt;Kendi başınıza proje geliştirmenin birçok avantajı bulunmaktadır. Herşeyden önce kendi hatalarınızı kendiniz
görmüş olursunuz. Proje geliştirirken birçok bilgi de beraberinde gelir. Ekip halinde çalışırken ekibe uyumlu olmak
zorundasınız. Birşeyleri değiştirmeniz kolay olmaz veya doğru bildiğiniz konuları hem siz yanlış uygulayabilirsiniz
hem de danıştığınız kişiler yanlış biliyor olabilir. O yüzden mutlaka kendi başınıza bir proje geliştirin.&lt;/p&gt;

&lt;p&gt;Biraz gelecekten gelmiş gibi olacağım ama :) Merak edenler varsa yukardaki eksiklikler konusunda ne olduğunu da yazayım.
Gösterim katmanı ve İşletme katmanı sorunlarını projeden hemen sonra anladım. Kısaca özetlersem gösterim katmanı sadece
io olmalı. Asıl işleri işletme katmanı yapmalı. Log yazmak konusu da projeden projeye değişen bir durum. Fakat veri
değiştiren işlemlerde mutlaka info seviyesinde log yazmalısınız. Test konusunda da oldukça rahatım. Tasarım desenleri
projeden sonra çalıştığım ilk konu oldu. Tasarım desenlerini sorsanız şu an en çok kullanılanları anlatırım.
Fakat tasarım desenlerine tam olarak hakim olmak için tecrübe gerekiyor. Bu konuda ne seviyedeyim ben de bilmiyorum.&lt;/p&gt;

&lt;p&gt;Temiz kod ise yine oldukça önemli. Bu konuda herhangi bir sorun yaşamıyorum. Hatta Akademik Bilişim 16 da &amp;ldquo;Temiz Kod&amp;rdquo;
kursu verdim.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/omerozkan/vipera&#34;&gt;Projenin Kaynak Kodu&lt;/a&gt;&lt;/p&gt;

&lt;div class=&#34;ui embed&#34;&gt;
    &lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/9b7ywcaut6Jz2j&#34; width=&#34;595&#34; height=&#34;485&#34;
            frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34;
            style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt;
    &lt;/iframe&gt;
&lt;/div&gt;

&lt;div class=&#34;ui hidden divider&#34;&gt;&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Bowling Katası</title>
      <link>https://omerozkan.net/bowling-katasi/</link>
      <pubDate>Mon, 09 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>https://omerozkan.net/bowling-katasi/</guid>
      <description>

&lt;p&gt;Robert C. Martin (Uncle Bob)&amp;lsquo;un hazırladığı bowling oyunu katasının videosunu hazırladım.
Zaman buldukça yeni katalar üretmeye ve videolarını hazırlamaya çalışacağım.&lt;/p&gt;

&lt;h3 id=&#34;bowling-oyununun-kuralları:7a957442c0f0cbc9e8daa6c7cecd2dea&#34;&gt;Bowling Oyununun Kuralları&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://omerozkan.net/images/post/bowling-kata/bowling-score.jpg&#34; alt=&#34;Bowling Skor Tablosu&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Oyunda toplamda 10 frame bulunmaktadır.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Her frame de ise 10 tane labutu vurmak için 2 atış hakkı bulunmaktadır.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Her frame’de vurulan toplam labut sayısı skoru gösterir.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Her frame’in başında eğer ilk atışta 10 adet labut birden vurulursa strike yapılmış olunur
ve sonraki iki atışta vurulan labut sayısı kadar bonus skor kazanılır.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Her frame’de 10 pin iki atışta vurulursa spare yapılmış olunur ve sonraki atıştaki vurulan labut sayısı kadar bonus kazanılır.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;10. frame diğerlerinden farklıdır. Bir sonraki atış olmayacağı için son frame’de strike yapılırsa &lt;strong&gt;2&lt;/strong&gt;, spare yapılırsa &lt;strong&gt;1&lt;/strong&gt; atış hakkı daha kazanılır.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Kurallara göre Bowling’de en yüksek skor, 12 strike ile 300’dür.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Üstteki resimde örnek bir skor tablosu gösterilmiştir. Daha detaylı bilgi için &lt;a href=&#34;https://tr.wikipedia.org/wiki/Bovling&#34;&gt;Wikipedi&lt;/a&gt;&amp;lsquo;den bilgi alabilirsiniz.&lt;/p&gt;

&lt;p&gt;Video &lt;a href=&#34;http://kodkata.com/bowling-game/&#34;&gt;Kod Kata&lt;/a&gt; sitesinde de yayınlanmıştır.&lt;/p&gt;

&lt;h3 id=&#34;video:7a957442c0f0cbc9e8daa6c7cecd2dea&#34;&gt;Video&lt;/h3&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/rklz35GWtrQ&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Powermock ve Mockito ile JSF Sınıflarını Test Etmek</title>
      <link>https://omerozkan.net/powermock-ve-mockito-ile-jsf-siniflarini-test-etmek/</link>
      <pubDate>Fri, 03 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>https://omerozkan.net/powermock-ve-mockito-ile-jsf-siniflarini-test-etmek/</guid>
      <description>&lt;p&gt;JSF Bean sınıflarında FacesContext gibi nesneler kullandığınızda ve bu sınıflara mock nesneler ile birim testleri yazdığınızda
&lt;a href=&#34;https://github.com/mockito/mockito&#34;&gt;Mockito&lt;/a&gt;, JMock gibi araçlar yeterli olmayacaktır. Örnek olarak aşağıdaki metodu inceleyelim.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/c9bd44aa073505b3514c.js?file=loginAction.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Bu metod basit bir login işlemi gerçekleştirmektedir.
Anlaşılacağı gibi xhtml sayfasında bir buton üzerinde actionListener parametresinde tanımlanmaktadır.
Öncelikle kullanıcı adı ve parolanın boş bırakılıp bırakılmadığını kontrol etmekte eğer alanlar boş değilse
business katmanı ile login işlemini gerçekleştirmektedir.&lt;/p&gt;

&lt;p&gt;Şimdi kodları inceleyelim.  &lt;strong&gt;2&lt;/strong&gt;. satır da JSF sayfasına mesaj göndermek için FacesContext nesnesini &lt;code&gt;FacesContext.getCurrentInstance()&lt;/code&gt;
statik metodu ile almaktadır. &lt;strong&gt;3&lt;/strong&gt;. satırda bir sınıf değişkeni yer almakta bu değişken sayesinde başka bir metod oturum açma işlemini gerçekleştirmektedir.&lt;br /&gt;
&lt;strong&gt;4&lt;/strong&gt;. satırdaki koşul kullanıcı adı ve parola alanlarının boş bırakılıp bırakılmadığını kontrol etmektedir.
&lt;strong&gt;8&lt;/strong&gt;. satır da ise loginManager nesnesi iş katmanının bir nesnesi olup DI (Dependency Injection) ile enjekte edilmektedir.
LoginManager bir interface&amp;rsquo;dir. Bu sayede LoginBean sınıfının iş katmanına bağımlılığı esnek olur.
Aynı zamanda test edebilmek için kolayca mock nesneleri oluşturabiliriz.
Alt katmandan gelen sonuç ise bir &lt;strong&gt;LoginResult&lt;/strong&gt; nesnesidir.&lt;/p&gt;

&lt;p&gt;Burdaki temel sorun &lt;strong&gt;2&lt;/strong&gt;. satırdaki FacesContext nesnesinin statik bir metod aracılığı ile alınmış olmasıdır.
Statik metodları Mockito gibi araçlarla taklid edemeyiz.
Burda benim aklıma gelen ilk çözüm, bir Java anotasyonu oluşturup, setter injection ile uygulama bir servlet container
içerisinde çalıştığında gerçek FacesContext nesnesini enjekte etmesini sağlamak ve test edildiğinde ise kolayca mock
nesneyi enjekte edebilmekti. Diğer çözümler için internette arama yaparken &lt;a href=&#34;https://github.com/jayway/powermock&#34;&gt;PowerMock&lt;/a&gt; ile karşılaştım.
PowerMock ile statik metodlara hatta private alanlara müdahale edebiliyorsunuz.&lt;/p&gt;

&lt;p&gt;Örnekte PowerMock ile Mockito araçlarını beraber kullandım. Mockito yerine dilediğiniz test aracını kullanabilirsiniz. (JMock, EasyMock vs.)&lt;/p&gt;

&lt;p&gt;Öncelikle bir setUp metodu oluşturalım:&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/c9bd44aa073505b3514c.js?file=loginBeanTest.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;32&lt;/strong&gt;. satır da FacesContext sınıfı Mockito ile mock&amp;rsquo;lanmaktadır. 37. satırda benzer şekilde LoginManager sınıfı mocklanmaktadır.
&lt;strong&gt;36&lt;/strong&gt;. satır da test edilecek olan sınıfın nesnesi üretilmektedir.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;33&lt;/strong&gt;. satır da &lt;strong&gt;mockStatic()&lt;/strong&gt; metodu kullanılarak FacesContext nesnesinin statik metodları mock&amp;rsquo;lanmış oldu.
&lt;strong&gt;34-35&lt;/strong&gt;. satırlarda PowerMockito.doReturn() metodu ile &lt;em&gt;FacesContex.getCurrentInstance()&lt;/em&gt; statik metodunun davranışı değiştirilmiştir.
Bu sayede birim testlerimizi çalıştırabiliriz. Örnek olarak bir test metodu ekleyelim:&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/c9bd44aa073505b3514c.js?file=loginWithEmptyUsername.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;4-6&lt;/strong&gt;. satırlarda gerekli test verileri girilip login işlemi gerçekleştirilmiştir. &lt;strong&gt;7&lt;/strong&gt;. satırda ise Mockito ile
&lt;code&gt;context.addMessage(null, INVALID_LOGIN)&lt;/code&gt; yani doğru metodun çağrılmasının testi yapılmıştır.&lt;/p&gt;

&lt;p&gt;Bu şekilde testler çalıştırıldığında olumsuz sonuç alırız.
PowerMockito&amp;rsquo;nun gereken sınıfları taklit etmesi için test sınıfının başına aşağıdaki gibi anotasyonlar tanımlanmalıdır:&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/c9bd44aa073505b3514c.js?file=loginBeanTest2.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; satırda testlerin PowerMockRunner ile çalışmasını ve &lt;strong&gt;2&lt;/strong&gt;. satırda ise &lt;strong&gt;FacesContext&lt;/strong&gt; sınıfına ait statik metodun mock&amp;rsquo;lanmasını sağladık.
Bu sayede testlerimiz çalışır hale gelmektedir.&lt;/p&gt;

&lt;p&gt;Bir başka yazıda görüşmek üzere&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Özgür Yazılım ve Kurumsal Java Semineri</title>
      <link>https://omerozkan.net/ozgur-yazilim-ve-javaee-semineri/</link>
      <pubDate>Mon, 27 May 2013 00:00:00 +0000</pubDate>
      
      <guid>https://omerozkan.net/ozgur-yazilim-ve-javaee-semineri/</guid>
      <description>

&lt;p&gt;4 Mayıs 2013 tarihinde Mustafa Kemal Üniversite&amp;rsquo;sinde Özgür Yazılım &amp;amp; GNU/Linux ve KurumsalJava &amp;amp; Web Teknolojileri başlıklı seminerler verdim.
Katılım sayısı hava sıcaklığından dolayı düşük olsa da yine de istediğim seminer ortamını buldum.
Çünkü öğrenmek isteyenler olunca ben de elimden geleni yapmak istedim. Çoğunluk 1. sınıf öğrencilerinden oluşmaktaydı.
Bu özgür yazılım semineri için güzel olsa da JavaEE semineri için dezavantajdı. Çünkü Java malesef okulumuzda 3. sınıfta anlatılıyor.&lt;/p&gt;

&lt;p&gt;Öncelikle “Özgür Yazılım” semineri ile başladım. Özgür yazılımın ve açık kaynak yazılımların ne tür bir yazılım olduğunu
ve lisanslarından bahsettim. Özgür yazılımın doğuşunun hikayesini de anlattım.
Daha sonra GNU/Linux hakkında daha önce hiç Linux kullanmamış kişilere yönelik tanıtım gerçekleştirdim.
Bu seminer zamanında tamamlamayı başardım ancak JavaEE semineri hiç de öyle olmadı :)
Dinleyenlerin çoğunluğu 1. sınıf olduğu için Java teknolojilerinden bahsederken bazı kavramlar hakkında da bilgi vermek zorunda kaldım.
Örneğin persistence katmanında kullanılan teknolojilerden bahsederken ORM’nin ne olduğunu anlatmak zorunda kaldım.
Fakat beni baya yordu açıkçası. Süreyi de baya aşmak durumunda kaldım.
Seminerlerin sonunda ise söz verdiğim gibi “Test Güdümlü Geliştirme”yi de anlattım. Birlikte roman rakamları katası yaptık.
Katılımcıların hiç birinin Java bilmemesine rağmen, TDD’nin doğası gereği çok verimli geçti.&lt;/p&gt;

&lt;p&gt;Hem katılımcılar için hem de benim için güzel tecrübe oldu.
Katılımcıların yazılıma bakış açısını değiştirdiğimi düşünüyorum.
En azından kurumsal java’yı tanıma fırsatı buldular. Umarım gelenler yazılıma hakkını vererek iyi bir yazılımcı olurlar.
Benim açımdan da çok iyi bir tecrübe oldu. Özellikle JavaEE seminerini detaylı bir şekilde anlatabildiğimi görerek birçok
konuda bilgi sahibi olduğumu anladım. Diğer taraftan da yaklaşık 4 saat ayakta kalmak da beni mahvetti.
Linux yaz kampında Hakan hocanın (Hakan Uygun) neler yaşadığını anlayabiliyorum :)&lt;/p&gt;

&lt;p&gt;Sunumların içeriğinin birçoğunu &lt;a href=&#34;https://www.ozguryazilim.com.tr&#34;&gt;Özgür Yazılım A.Ş.&lt;/a&gt; firmasının yaptığı &lt;a href=&#34;http://topluluk.ozguryazilim.com.tr/sunumlar&#34;&gt;sunumlar&lt;/a&gt;dan
aldım. Seminerler konusunda da tavsiyelerini esirgemedikleri için burdan da teşekkür ediyorum.
Sunumları aşağıdaki linklerden edinebilirsiniz.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://omerozkan.net/sunumlar/ozgur-yazilim.pdf&#34; target=&#34;_blank&#34;&gt;Özgür Yazılım ve Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://omerozkan.net/sunumlar/kurumsaljava.pdf&#34; target=&#34;_blank&#34;&gt;Kurumsal Java&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;slideshare:9bca51cfe4f1f522d373652315ef8a90&#34;&gt;Slideshare&lt;/h2&gt;

&lt;h3 id=&#34;özgür-yazılım-ve-linux:9bca51cfe4f1f522d373652315ef8a90&#34;&gt;Özgür Yazılım ve Linux&lt;/h3&gt;

&lt;div class=&#34;ui embed&#34;&gt;
    &lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/Jj95uRITPMjhv8&#34; width=&#34;595&#34; height=&#34;485&#34;
            frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34;
            style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt;
    &lt;/iframe&gt;
&lt;/div&gt;

&lt;div class=&#34;ui hidden divider&#34;&gt;&lt;/div&gt;

&lt;h3 id=&#34;kurumsal-java:9bca51cfe4f1f522d373652315ef8a90&#34;&gt;Kurumsal Java&lt;/h3&gt;

&lt;p&gt;&lt;div class=&#34;ui embed&#34;&gt;
    &lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/K1xxNf1LPcfYz4&#34; width=&#34;595&#34; height=&#34;485&#34;
            frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34;
            style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt;
    &lt;/iframe&gt;
&lt;/div&gt;

&lt;div class=&#34;ui hidden divider&#34;&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OOP: Polimorfizm</title>
      <link>https://omerozkan.net/oop-polimorfizm/</link>
      <pubDate>Tue, 13 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>https://omerozkan.net/oop-polimorfizm/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://omerozkan.net/oop-kapsulleme/&#34;&gt;Kapsülleme&lt;/a&gt; ve &lt;a href=&#34;https://omerozkan.net/oop-kalitim/&#34;&gt;kalıtım&lt;/a&gt; konularından sonra sıra geldi polimorfizme.
Polimorfizm, Türkçe&amp;rsquo;de çok biçimlilik olarak çevriliyor.
Polimorfizmi anlatmak için JUnit in Action kitabında gördüğüm güzel bir örneği vereceğim.
Bu örnek sayesinde polimorfizm&amp;rsquo;in kullanım amacını da göstermiş olacağım. Örnek göstererek anlatmayı daha uygun buldum.
Ben önce örnekleri inceleyip sonra açıklamaları okurdum. Bu sayede daha kolay kavrıyorum.
Aynı yöntemi burda da uygulayacağım. Bu konuyu kavramanız için kalıtım konusuna hakim olmanız gerekmektedir.&lt;/p&gt;

&lt;p&gt;Örneğimizde bir yazıcımız var. Bu yazıcı kelime işlemci ve pdf belgelerini basabiliyor.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=pdf1.java&#34;&gt;&lt;/script&gt;
&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=word1.java&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;PDF ve Word sınıfları getPrintableText() isimli bir metodu içeriyor. Şimdi de yazıcı (Printer) sınıfımıza bakalım.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=printer1.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Printer sınıfımızın ise iki metodu var. printPDF metodu PDF dökümanını, printWord metodu ise word dökümanını yazdırıyor.
Bu metodlar bu nesneleri parametre olarak alıp, PDF ve Word sınıflarının getPrintableText metodunu kullanarak ekrana yazabiliyor.&lt;/p&gt;

&lt;p&gt;Bu tasarım başlangıçta güzel gözükse de aslında bir çok problemi beraberinde getiriyor. &lt;strong&gt;printPDF&lt;/strong&gt; ve &lt;strong&gt;printWord&lt;/strong&gt; metotları
nerdeyse birbirinin aynısı. Yani duplicated kod barındırıyor. Diğer bir problem diyelim ki müşteriniz Excel tablolarını
da yazdırmak istedi. Ne yapmanız gerekiyor. Öncelikle bir Excel sınıfı ekleyip ardından &lt;strong&gt;Printer&lt;/strong&gt; sınıfına &lt;strong&gt;printExcel()&lt;/strong&gt; adlı
yine aynı işi yapan bir metot eklemeniz gerekiyor. Bu sefer üç tane metod aynı işi yapmış olacak. Yer yeni bir belge türü
eklediğimizde Printer sınıfını sürekli değiştirmemiz gerekiyor. Bu durum Open-Close (Açık-Kapalı) prensibine aykırı bir durum.
Open-Close prensibi yazdığımız sınıfların gelişime açık fakat değişime kapalı olması gerektiğini tanımlar. Bu durumu
polimorfizm ile düzeltebiliriz.&lt;/p&gt;

&lt;p&gt;Öncelikle daha önceden öğrendiğimiz kalıtımı(yemek tarifi gibi oldu :)) kullanarak sınıflarımızı yeniden yapılandıralım.
&lt;strong&gt;PDF&lt;/strong&gt; sınıfıda &lt;strong&gt;Word&lt;/strong&gt; sınıfıda aslında birer belge yani &lt;strong&gt;Document&lt;/strong&gt; özelliğini taşıyor.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=document.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Şimdi Word ve PDF sınıflarını Document sınıfını &lt;strong&gt;extend&lt;/strong&gt; edebilir.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=word2.java&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=pdf2.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Override anotasyonunu (annotation) görüyorsunuz. Anotasyonlar Java 1.5&amp;rsquo;ten sonra gelen bir özelliktir.
Buradaki Override anotasyonu, Word ve PDF&amp;rsquo;te bulunan getPrintableText metodlarının ata sınıfın (Document) print metodunun değiştirildiği anlamına gelir.&lt;/p&gt;

&lt;p&gt;Şimdi &lt;strong&gt;Printer&lt;/strong&gt; sınıfını da yeniden düzenleyelim.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=printer2.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Şimdi daha iyi anlamanız için bir test sınıfı yazalım.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=printerTest.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Eğer sonucu görmediyseniz lütfen sonucu tahmin etmeye çalışın.&lt;/p&gt;

&lt;p&gt;Bu kodun ekran çıktısı aşağıdaki gibi olacaktır.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;This is a document&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;This is a PDF document&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;This is a Word document&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;4. satırda yeni bir yazıcı sınıfı ürettik.
6. satırda bir döküman nesnesini yazdırdık. Beklediğimiz gibi Document sınıfında tanımladığımız metni yazdırdı.
8. satırda ise bir pdf belgesini yazdırmak istedik. Printer sınıfının parametre referans tipine baktığınızda Document olduğunu
görüyorsunuz. PDF de bir document nesnesi olduğu için bu nesneyi bu metoda geçirebildik(passing). Bu polimorfizmin birinci
durumu. Yani Document sınıfını extend eden herhangi bir nesneyi Document referansı ile kullabiliriz. Bunu şu şekilde de
tanımlayabilirdik.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Document document = new PDF()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Yani Document dışında farklı sınıfların nesnelerini de Document referansı ile tanımlayabiliriz. Bunu polimorfizm sağlar.
Polimorfizmin sağladı diğer bir güzellik ise ekranda gördüğünüz &amp;ldquo;This is a PDF document&amp;rdquo; yazısıdır. Document sınıfında
tanımlanan varsayılan davranış yerine PDF sınıfında bu davranışı değiştirerek farklı metin yazmasına sebep olduk. Bu şekilde
her nesnenin bir metod veya herhangi bir interface(java&amp;rsquo;daki interface&amp;rsquo;leri kastetmiyorum) için farklı davranış göstermesine &lt;strong&gt;polimorfizm&lt;/strong&gt; diyoruz.&lt;/p&gt;

&lt;p&gt;10. satırda aynı durum Word sınıfı için geçerli. Ayrıca Printer sınıfının tek bağımlılığı Document sınıfına oldu. Yani
Printer ve Document sınıfını bir jar içerisinde müşteriye teslim edebiliriz. Bu da bize esnek bir yapı sağlar.&lt;/p&gt;

&lt;p&gt;Şimdi gelelim müşterinin isteğine, müşteri bir Excel dosyası yazdırmak istemişti. Artık Printer sınıfına dokunmamıza bile gerek yok.
Yeni bir Excel sınıfı ekleyelim.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=excel.java&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;super-anahtar-kelimesi:1e4f0b0da4b93aa40114849c5b8e437e&#34;&gt;super anahtar kelimesi&lt;/h3&gt;

&lt;p&gt;Java&amp;rsquo;da nesneyi üst sınıfın interface i ile kullanmak isterseniz. &lt;code&gt;super&lt;/code&gt; anahtar kelisini (keyword) kullanabilirsiniz.
Örneğimize bakarsak PDF sınıfı Document&amp;rsquo;in print metodunun üzerine kendi &lt;strong&gt;getPrintableText()&lt;/strong&gt; metodunu deği davranışını
değiştirmiş oldu ve Document sınıfında tanımlanan print metodunun davranışını iptal etti.
Peki PDF sınıfı atasından (Document) aldığı &lt;strong&gt;getPrintableText()&lt;/strong&gt; metodunu kullanmak isterse ne yapmalıyız?
İşte burda super anahtar kelimesini kullanabiliriz. PDF sınıfını aşağıdaki şekilde değiştirelim.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=pdf3.java&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Bunun sonucunda &lt;strong&gt;getPrintableText()&lt;/strong&gt; metodu &amp;ldquo;This is a document\nThis is a PDF document\n&amp;rdquo; değerlerini döndermiş olur.&lt;/p&gt;

&lt;p&gt;Polimorfizm kavrami OOP&amp;rsquo;ye özgür bir özellik değildir. OOP ile uygulanabilir.&lt;/p&gt;

&lt;p&gt;Bu yazımda polimorfizmi yüzeysel olarak anlatmaya çalıştım. Umarım faydalı olmuştur.&lt;/p&gt;

&lt;p&gt;Bir sonraki yazıda görüşmek üzere&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OOP: Kalıtım</title>
      <link>https://omerozkan.net/oop-kalitim/</link>
      <pubDate>Sat, 03 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>https://omerozkan.net/oop-kalitim/</guid>
      <description>&lt;p&gt;Bir önceki yazımda OOP konusuna giriş yapmış ve kapsüllemeyi anlatmıştım.
Bu yazımda ise &amp;ldquo;Kalıtım&amp;rdquo; konusundan bahsetmek istiyorum.
Kalıtım (inheritance) kelimesi aslında biyolojide anlamı ile aynıdır.
Adından da anlaşılacağı gibi bir sınıfın özelliklerini diğer sınıfa olduğu gibi aktarmasıdır.&lt;/p&gt;

&lt;p&gt;Peki böyle bir özelliğe neden ihtiyaç duyarız.
Bir üniversitedeki öğretim görevlilerini ve öğrencileri modelleyen iki sınıf tanımlayalım.
Öğrenci sınıfı öğrencinin adını, soyadını, okul numarasını, T.C. kimlik numarasını, bölümünü içersin.
Öğretim görevlisi sınıfı ise öğretim görevlisinin adını, soyadını, hangi bölümün kadrosunda yer aldığını,
T.C. kimlik numarasını ve akademik ünvanını içersin. Bunu Java kodları ile ifade edersek:&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/84daffabbbc96abca820.js?file=lecturer1.java&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/84daffabbbc96abca820.js?file=student1.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Student&lt;/strong&gt; ve &lt;strong&gt;Lecturer&lt;/strong&gt; adında Java sınıflarımız var.
Bu sınıflar gördüğünüz gibi basit bir şekilde getter ve setter metodlarından oluşuyor.
Bu iki sınıf arasındaki benzerlikleri düşünelim. id (T.C. Kimlik No) , name, surname, department değerleri aynı.
Örneğin bir de üniversitede çalışan memurları modellersek yine aynı verileri tekrarlamak zorundayız. Bu da tekrarlı koda (duplicated code)
sebep olur. Bu durum &lt;strong&gt;DRY (Don&amp;rsquo;t Repeat Yourself)&lt;/strong&gt; prensibine aykırı.&lt;/p&gt;

&lt;p&gt;Bu sorunu kalıtım (inheritance) kullanarak çözebiliriz. Bunun için öncelikle Person adlı bir sınıf tanımlıyoruz ve bu sınıfa
&lt;strong&gt;Lecturer&lt;/strong&gt; ve &lt;strong&gt;Student&lt;/strong&gt; sınıfların ortak özelliklerini yerleştiriyoruz.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/84daffabbbc96abca820.js?file=person.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Gördüğünüz gibi Person sınıfımız önceki tanımladığımızın iki sınıfın özelliklerini içeriyor.
Burada dikkat ederseniz bölümü eklemedim. Bunun sebebi uygulamamıza ekleyeceğimiz diğer personeller herhangi bir bölümde olmayabilirler.
Ama her personelin T.C kimlik numarası, adı ve soyadı olmak zorunda.
Student ve Lecturer sınıflarını aşağıdaki gibi değiştirebiliriz.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/84daffabbbc96abca820.js?file=lecturer2.java&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/84daffabbbc96abca820.js?file=student2.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Student ve Lecturer sınıflarının tanımlarına dikkat edersek &lt;strong&gt;extends Person&lt;/strong&gt; ifadesini görüyoruz.
Java&amp;rsquo;da kalıtım &lt;strong&gt;extends&lt;/strong&gt; anahtar kelimesi ile yapılır.
Kalıtım ile Person sınıfının bütün özelliklerine hem Student hem de Lecturer sınıfı sahip oldu.
Yani Student ve Lecturer sınıfı da id, name, surname alanlarına ve getter/setter metodlarına sahip.
Bu sayede kod tekrarından kurtulmuş olduk.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Not:&lt;/strong&gt; Önceki yazımda erişim belirleyicilerinden bahsetmiştim.
private ile tanımlanan metodlar veya alanlara sınıf dışından erişilemez.
Burada name, surname ve id alanlarına direkt olarak erişemeyiz.
Fakat public olan getter ve setter metodları sayesinde bu değişkenlere erişmemiz mümkün.
Sadece genişletilen (türetilen) sınıflardan (Student ve Lecturer) erişmek isteseydik name, surname ve id alanlarını
 &lt;strong&gt;protected&lt;/strong&gt; erişim belirleyicisi ile tanımlamamız yeterli olacaktır.
 &lt;strong&gt;protected&lt;/strong&gt; ile tanımlanan alanlar ve metodlar aynı zamanda aynı paket içerisindeki diğer sınıflar tarafından da erişilebilir.&lt;/p&gt;

&lt;p&gt;Kalıtımın diğer sağladığı bir özellik OOP&amp;rsquo;de polimorfizme imkan sağlamasıdır. Bunun için &lt;a href=&#34;https://omerozkan.net/oop-polimorfizm/&#34;&gt;OOP: Polimorfizm yazısını&lt;/a&gt; okuyabilirsiniz.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OOP: Kapsülleme</title>
      <link>https://omerozkan.net/oop-kapsulleme/</link>
      <pubDate>Fri, 02 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>https://omerozkan.net/oop-kapsulleme/</guid>
      <description>

&lt;p&gt;Blogumda yazılım ile ilgili pek bir yazı olmadığından artık bazı konularda yazılar yazmaya karar verdim.
Bu yüzden programlamanın en temel ve en önemli konularından biri olan Nesne Yönelimli Programlama&amp;rsquo;yı elimden geldiği kadar anlatmaya çalışacağım.
Object Oriented Programming bir programlama yaklaşımıdır. Nesneye yönelik programlama, nesneye dayalı programlama,
nesne tabanlı programlama, nesne esaslı programlama gibi bir çok çevirisi vardır. Ben de Türkçe de daha çok yaygın olan nesne
yönelimli programlamayı kullanıyorum. Fakat genelde bahsederken OOP olarak kısaltacağım.&lt;/p&gt;

&lt;p&gt;Yazılım gereksinimleri arttıkça prosedürel programlama bir çok sorunu beraberinde getiriyordu.
Bu sorunlara kod karmaşıklığının artması, bakımın oldukça zor olması, ekip halinde çalışmayı zorlaştırması,
maliyetlerin artması örnek olarak verilebilir. Bütün bu sorunların sonucu olarak da &amp;ldquo;Nesne Yönelimli Programlama&amp;rdquo; ortaya çıkmıştır.
OOP ilk olarak 60&amp;rsquo;lı yıllarda Norveç&amp;rsquo;te geliştirilen &lt;strong&gt;&amp;ldquo;Simula&amp;rdquo;&lt;/strong&gt; programlama dili ile ortaya çıkmıştır. Simula ise &lt;strong&gt;ALGOL&lt;/strong&gt; tabanlı
bir programlama dilidir. Günümüzde hemen hemen bütün modern diller OOP desteklemektedir. OOP&amp;rsquo;nin bu kadar popüler olmasının
bir sebebi var. Merak edenler için &amp;ldquo;SOLID&amp;rdquo; anahtar kelimesini vereyim.
Fakat bu yazı dizisinde OOP&amp;rsquo;nin en temel özelliklerini anlatacağım.
OOP&amp;rsquo;yi anlatırken Java&amp;rsquo;da sınıflar ve nesneler konusunda bilgi sahibi olduğunuzu varsayacağım.&lt;/p&gt;

&lt;p&gt;OOP denilince akla üç (bazı kaynaklara göre dört) özellik geliyor. Bunlar:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Encapsulation (Kapsülleme)&lt;/li&gt;
&lt;li&gt;Inheritance (Kalıtım)&lt;/li&gt;
&lt;li&gt;Polymorphism (Polimorfizm veya Çok biçimlilik)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bazı kaynaklar Abstraction (Soyutlama)&amp;lsquo;ı da dahil etmektedir. Daha önce ben de bu şekilde tanımlardım.
Soyutlama ise çok daha geniş bir konu olduğundan üç özellik olarak tanımlamayı tercih ediyorum. Bu yazı dizisinde
soyutlamaya da yer vereceğim.&lt;/p&gt;

&lt;h2 id=&#34;encapsulation-kapsülleme:ec6c8a1cc144b0e8e50636ff4e409a35&#34;&gt;Encapsulation (Kapsülleme)&lt;/h2&gt;

&lt;p&gt;Kapsülleme de aslında bir çok şekilde yapılabilir. Fakat basit olması amacı ile en kolay yönden tanımlayacağım.&lt;/p&gt;

&lt;p&gt;Kapsüllemeyi kısaca tanımlarsak bir nesnenin iç yapısını (verilerini ve özelliklerini) dış dünyadan doğrudan erişime kapatılması anlamına gelir.
Bu sayede nesneye ait veriler değer ataması yapılırken yanlış kullanımdan korunmuş olur. İç yapısının dışarıya açık olmaması
aynı zamanda iç yapı ile ilgili değişikliklerin dış dünyanın etkilenmemesini de sağlamış olur. Bu açıdan çok önemlidir.&lt;/p&gt;

&lt;p&gt;Java programlama dilinde nesne elemanlarının dışarıya kapatılması için &lt;strong&gt;private&lt;/strong&gt; erişim belirteci kullanılır.
Java&amp;rsquo;da dört &lt;em&gt;erişim belirleyicisi (access modifier)&lt;/em&gt; vardır. Bunları kısaca tanımlarsak:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;public&lt;/strong&gt;: public kelimesi halka açık veya kamu anlamına gelmektedir.
Bu erişim belirleyicisi ile tanımlanan herşey diğer bütün sınıflar tarafından erişilebilir.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;private&lt;/strong&gt;: özel veya gizli anlamına gelir.
Bu erişim belirleyicisi ile tanımlanan herhangi bir eleman sadece ve sadece aynı sınıf içerisinden erişilebilir. Yani diğer sınıflar
hiç bir şekilde erişemez.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;package-private&lt;/strong&gt;: Adı üstünde paket anlamına gelir. Bu erişim belirleyicisi ile işaretlenen herşey sadece ve sadece
aynı paket içerisinde tanımlanan sınıflar tarafından erişilebilir. Farklı paketlerde bulunan sınıflar erişemez.
Java&amp;rsquo;da değişkenleri, metodları vs. diğer erişim belirleyicisilerle tanımlamazsanız, &lt;em&gt;package-private&lt;/em&gt; olarak tanımlamış
olursunuz. Yani package veya package-private gibi kelimeler kullanılmaz.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;protected&lt;/strong&gt;: Korumalı anlamına gelir. Bu erişim belirleyicisi ile herhangi bir eleman türetilmiş olan ve aynı paket içerisinde olan sınıflar içerisinden erişilebilir.
(Kalıtım konusunda anlatılacaktır.)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bunlara kullanarak örnek bir sınıf tasarlayalım.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0e06db9d134e6d5699ba.js?file=accessModifierTest.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Payı (numerator) ve paydası (denominator) olan basit bir Rational (rasyonel) sınıfı tanımlayalım.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0e06db9d134e6d5699ba.js?file=rational.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Bu sınıfın iki değişkeni var: &lt;strong&gt;&lt;em&gt;numerator&lt;/em&gt;&lt;/strong&gt; ve &lt;strong&gt;&lt;em&gt;denominator&lt;/em&gt;&lt;/strong&gt;.
Bu iki değişken sınıfa ait olduğu için alan (field) olarak tanımlayabiliriz.
Bu iki alanın erişim belirleyicisini &lt;strong&gt;private&lt;/strong&gt; olarak belirledik.
Bu sayede sınıf dışından erişimi kapatmış olduk.
Örneğin başka bir sınıftan aşağıdaki gibi bir kullanım hatalı olacaktır.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0e06db9d134e6d5699ba.js?file=rationalClient.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Ayrıca dikkatlice incelerseniz &lt;strong&gt;&lt;em&gt;Rational&lt;/em&gt;&lt;/strong&gt; sınıfında &lt;strong&gt;&lt;em&gt;IllegalDenominator&lt;/em&gt;&lt;/strong&gt; sınıfı da tanımlanmış. Bu tür sınıflara
&lt;strong&gt;inner-class&lt;/strong&gt; diyoruz. Bu sınıfında bir erişim belirteci var. public olması sebebi ile bu sınıfa dışarıdan herkes erişebilir.&lt;/p&gt;

&lt;p&gt;Rational sınıfına dikkat ederseniz getter ve setter metodlarımnız var (Örneğin: getNumerator(), setNumerator()).
Bu metodların erişim belirleyicisi de &lt;strong&gt;&lt;em&gt;public&lt;/em&gt;&lt;/strong&gt; yani dışardan erişime açık.
Bu sayede numerator ve denominator değişkenlerine bu metodlar aracılığı ile değer atanabilir. Aşağıdaki kullanım doğru olacaktır.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0e06db9d134e6d5699ba.js?file=rationalClient2.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;setNumerator&lt;/em&gt;&lt;/strong&gt; ve &lt;strong&gt;&lt;em&gt;setDenominator&lt;/em&gt;&lt;/strong&gt; sayesinde numerator ve denominator değişkenlerine değer atanmış oldu.
Burada gördüğünüz set ile başlayan metodlara &lt;strong&gt;setter&lt;/strong&gt; adı verilir.
Aynı şekilde bu alanların değerlerine erişmek için &lt;strong&gt;&lt;em&gt;getNumerator&lt;/em&gt;&lt;/strong&gt; ve &lt;strong&gt;&lt;em&gt;getDenominator&lt;/em&gt;&lt;/strong&gt; metodlarını kullanabiliriz.
Bu şekilde tanımlanan metodlara da &lt;strong&gt;getter&lt;/strong&gt; adı verilir.&lt;/p&gt;

&lt;p&gt;setDenominator metodunu detaylı inceleyelim. 15. satırda bir koşul olduğunu görüyorsunuz.
Eğer denominator&amp;rsquo;e yani paydaya 0 değeri atanmaya çalışıldığında,
bu metod Exception fırlatarak paydanın 0 olmasını engellemiş oluyor.
Bu sayede yanlış kullanımı engellemiş olduk. Bu sayede veri bütünlüğü ve kontrolü sağlanmış oldu.
Genelde bütün alanlar geçerli bir sebep olmadıkça private olarak tanımlanır. Yani dışarıya kapatılmalıdır.
Her alan için getter ve setter metodları tanımlamak zorundayız diye de düşünmeyin.
Böyle bir zorunluluk yok. getter ve setter metodlar olmadan farklı metodlar aracılığı ile de erişimi kontrol altına alabilirsiniz.
Örneğin sınıfımıza 3 tane constructor metod ekleyelim.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0e06db9d134e6d5699ba.js?file=rational2.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Bu tasarımımız da farklı bir örnek oldu. Dikkat ederseniz bu tasarımımızda setter metodları kaldırdık.
Bu sınıfı kullanan istemci artık sadece nesne üretirkendeğerleri verebilecek nesne üretildikten sonra değerini değiştiremeyecektir.
nominator ve denominator değişkenleriniprivate olarak tanımladığımız için istemcinin doğrudan ne de dolaylı olarak
değerini değiştiremez. Bu tarz sınıflara &lt;strong&gt;immutable&lt;/strong&gt; sınıf adı verilir.&lt;/p&gt;

&lt;p&gt;Bu yazıda kısaca encapsulation yani kapsüllemeyi anlattım. Bir sonraki yazıda görüşmek üzere&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hedefim Kurumsal Java</title>
      <link>https://omerozkan.net/hedefim-kurumsal-java/</link>
      <pubDate>Sun, 12 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>https://omerozkan.net/hedefim-kurumsal-java/</guid>
      <description>&lt;p&gt;Bilgisayar mühendisliği okuyan her öğrencinin veya mezunun bir alan seçmesi ve o alanda uzmanlaşması gerekir.
Her alanda uzmanlaşmak mümkün değildir. Bilgisayar mühendisliği çok genel bir alan.
Üniversitelerimizde malesef herşeyin temeli anlatılıyor.
Uzmanlaşmak için bir alan seçip o alanda okuldan bağımsız bir şekilde ilerlemek gerekiyor.
Mezun olduğumuzda ise 0. basamaktan başlıyoruz. Bütün bunların farkına varınca benim de bir seçim yapmam gerekti.
Bazı alanlarda çalışıp birşeyler öğrenmeye çalışınca hiç bir alanda ilerleme kaydedemediğimi farkettim.&lt;/p&gt;

&lt;p&gt;2. Sınıfın başlangıcında böyle bir arayışa girdim. “Hangi alanı seçmeliyim?”  sorusunu bütün bir yıl boyunca kendime sordum.
Seçim yaparken genelde mühendisler, piyasada en çok kullanılan teknolojilere, programlama dillerine doğru yöneliyorlar.
Tabiki de haklılar. Beni de piyasa oldukça etkiledi. Fakat bunun önünde seçmem gereken alan sevdiğim bir alan olması gerekiyordu.
Sevmediğim bir işte olgunlaşmam mümkün değildir. 3. sınıfa başlamadan kararımı verdim.&lt;/p&gt;

&lt;p&gt;İlk teknik serviste çalışmaya başlamıştım. Başta oldukça zevkli gelse de bir süre sonra sıkılmaya başladım.
Ardından web siteleri yayınlamaya başladım. Daha sonra ilk “Merhaba Dünya”yı PHP ile yazdım.
Hemen ardından MySQL ile CRUD işlemleri gerçekleştirdim. Web o zamandan beridir benim için vazgeçilmez oldu.
O zamanlar web ve masaüstü programcılığı popülerdi. Nedense masaüstü programcılığına pek ilgim olmadı.
Web sayfaları oluşturmak daha zevkli geliyordu. Yine o zamanlar, GNU/Linux’a ilgi duymaya başladım.
Tabiki GNU/Linux’un içerisine girince açık kaynaklı ve özgür yazılımları kullanmaya başladım.
GNU/Linux, Windows işletim sistemine göre daha cazip geliyordu.
Başta alışmak için zorluk çeksemde performansı ve esnekliği ile benim için vazgeçilmez oldu.
Seçimlerimi etkileyen 2 önemli faktör; birincisi web ikincisi ise GNU/Linux oldu.
Bu yüzden Microsoft’un teknolojileri hiç ilgimi çekmedi. Java’nın ne olduğunu neler yapılabildiğini öğrendim.
Bu dil o zamanlar öğrenmek istediğim programlama diliydi. Lise hayatı böyle geçti.
Web sayfaları geliştirdiğim için HTML, CSS ve Javascript gibi teknolojileri de öğrenmek zorunda kaldım ve aynı zamanda web tasarım da yaptım.&lt;/p&gt;

&lt;p&gt;Üniversiteye başladığım ilk yılda nesne yönemli programlama (Object-Oriented Programming) öğrenmeye başladım. C++ ile algoritmamı daha da geliştirdim.
C++ sevdiğim keyif aldığım programlama dillerinden biridir.
Veritabanı sistemleri çok ilgimi çektiğinden veritabanı ile ilgili bir dalda uzmanlaşmayı düşünüyordum.
Daha sonra mobil programlama öğrenmek istedim. Fakat çalışacak zaman ayırmadığım için mobil konusunda herhangi bir çalışma yapmadım.
Aslında bunun sebebi Java’yı bilmememden kaynaklanıyordu. Java ortamını ve programlama dilini öğrenmeye başladım.
Okulda öğrendiğim C# .Net hiç ilgimi çekmedi. Aynı şekilde masaüstü programcılığı da. O zamanlar Python da ilgimi çekmeye başlamıştı.
Hatta 6 bölüm Python kitabı okudum :) Java dili öğrenmeye devam ederken. Php ile MVC öğrenmeye başladım.
Zend Framework’ü tercih ettim. İşlerin ne kadar kolaylaştığını gördüm. Kararımı vermiştim: Java, Python, Ruby ve PHP.
2. Sınıfın bitmesine yakın bu kadar programlama dili yerine tek bir dil öğrenmeye karar verdim. Bu kararım Java oldu.
Java ile birçok şey öğrenirken Özcan Acar‘ı takip etmeye başladım.
Test güdümlü yazılım, refactoring, çevik yöntemler, tasarım şablonları vs derken yazılıma bakış açım değişmeye başlamıştı ve
katıldığım Linux yaz kampında JavaEE’yi yakından tanıma fırsatı buldum. Yazılıma bakış açım artık tamamen değişti.
Kendimi hiç böyle mutlu hissetmemiştim. Öğrenecek bir sürü güzel şeyler var.
Bir sürü programlama dili öğrenmek yerine kurumsal java ve java web teknolojilerinde uzmanlaşmak, kurumsal javanın derin sularında yüzmek istiyorum.
Proje yöneticiliği gibi alanları da düşündüm. İlerde bu alanda da belki çalışabilirim ama kesinlikle yazılımı bırakacağımı düşünmüyorum.&lt;/p&gt;

&lt;p&gt;Kararım tabiki kurumsal java oldu. Okul döneminin geri kalanında olmazsa olmaz yazılım prensipleri, test güdümlü yazılım,
çevik yöntemler, refactoring gibi konulara ayıracağım. JavaEE konusunda öğrenmeye devam edeceğim.
Veritabanı konusunda da fazla detaya girmeden PostgreSQL öğrenmek istiyorum.
Aynı şekilde JVM üzerinde çalışan Groovy programlama dilini de öğrenmek istiyorum.
Java ile geliştirirken groovy işime yarayabilecek araçlardan biri olduğunu düşünüyorum.
Programlama dillerini dostum olarak görürüm. En iyi dostum ise Java.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux Yaz Kampı - 2</title>
      <link>https://omerozkan.net/linux-yaz-kampi-2/</link>
      <pubDate>Sun, 15 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>https://omerozkan.net/linux-yaz-kampi-2/</guid>
      <description>&lt;p&gt;Bolu&amp;rsquo;da yaz kamp devam ederken, teorik eğitim sona ermişti. Artık kod yazmanın zamanı gelmişti.
Yazacağımız uygulama Tekir ön muhasebe projesiydi. Bu arada sınıftaki öğrenci sayısı da azalmaya başlamıştı.
Daha sonra ekiplere ayrıldık. Toplam 5 ekip vardı. Ben de controller (Java) sınıfı yazmak istediğim için ekip4&amp;rsquo;te yer almak istedim.
Proje içerisinde kod satırı / gün sayısı hesabına göre az iş yapsak da Scrum çevik yöntemini uyguladık.
Ekip olarak biz de çok az iş vardı. Öncelikle basit bir temel ayar sayfası ve JournalEntry nesnelerini kontrol eden bir Api yazacaktık.
Ben tabiki Api yazan ekipte yer aldım. Ekibimiz 10 kişiydi, 6 kişi Api, diğer 4 kişi ise ekran sayfası üzerine yoğunlaştılar.
Başlangıçta çok hevesliydim. Teorik kısımda kafamda soru işaretleri olduğu için ekip içerisinde aktif olmak istedim.
İşe başlamadan önce  JournalEntry sınıfı ve ilişkili bütün sınıfların UML diyagramlarını çizerek Hakan Hoca&amp;rsquo;nın yanına gittim.
Detaylı bir şekilde neleri kontrol edip edemeyeceğimizi öğrendik.
Aslına bakarsanız oturup tek başıma 20dk da belki de daha kısa sürede bitirebileceğim bir işti :)
Fakat diğer ekip arkadaşlarımın daha iyi öğrenmesi amacı ile ben kod yazmak istemedim. 6 kişi ile bir yumurta taşıyacaktık.
Neyse işleri tam orta yerinden 2&amp;rsquo;ye böldük. 6 kişi, 3 er kişilik alt ekiplere bölünmüştü. Mehmet ve Nursel bizim ekipteydiler.
Öncelikle Nursel&amp;rsquo;i bilgisayar başına geçirdik. Mehmet ve ben de yanında yazdırmaya devam ediyorduk.
Nursel&amp;rsquo;den sonra Mehmet bilgisayar başına geçti ve işi kısa sürede bitirdik. Diğer alt ekip halen devam ediyordu.
Bu sefer ben geçtim bilgisayar başına refactoring konusunda sadece fikir sahibi olmama rağmen kendi kodlarımıza refactoring uyguladım.
Daha anlaşılır ve daha sade bir kod yapısı oluştu.&lt;/p&gt;

&lt;p&gt;Diğer alt ekipte kendi kodlarını tamamladıktan sonra sınıfımız oluşmuş oldu.
Fakat bu controller sınıfının (JournalEntryApi) doğru yazıp yazmadığımızı test etmemiz gerekliydi.
Bunun için birim testleri uygulayacaktık (JUnit).
Test güdümlü yazılımı (Test Driven Development) çok merak ettiğim için baya sevinmiştim.
JournalEntryApi sınıfı ile ilgili bir detaya yer vermek istiyorum.
Hataları bir liste içerisinde tutuyorduk ki ekip5 de verilerin XML, SOAP, MQ gibi servislerle import edilmesini sağlıyordu.
Sonuçta hata varsa, hata kodlarına göre işlem yapmaları gerekmekteydi.
Hem testlerde rahat edebilmemiz için hem de ekip5&amp;rsquo;in işini biraz daha kolaylaştırmak amacı ile kendi hata modelimizi yazdık.
Bu modelimiz basit bir şekilde bir hata numarası ve hata açıklaması vardı. Testleri yaparken de sadece hata numarası ile yapacaktık elbette.
Hata modelini yazarken bir ekip arkadaşımız, bana laf sokmaya kalkınca moralim baya bir bozuldu. Sonuçta ben de bir yazılım geliştiricisi olmak için çalışan biriyim.
Yanlış da yapabilirim ki birçok hatam vardı elbette. Ama yine de kendi mesleğime,
kişiliğime laf sokulması kesinlikle kabul edemeyeceğim bir olaydır. Yine kendisini rezil etmemek için olayı açıklamayacağım.&lt;/p&gt;

&lt;p&gt;Moralim bozulunca geri çekildim ve ne yapabilecekler diye uzaktan bekledim.
Ekip içerisindeki heyecanımın yok olduğunu ekiptekilerin bir kısmı farketti. Mehmet, JUnit ile ilgili güzel veriler edindi.
Kafama takılan birkaç şeyi ona sordum. Sami ise JUnit testi yazmaya çalışıyordu. Bu arada Hakan hoca JUnit&amp;rsquo;i nasıl kullanacağımızı basitçe anlatmıştı.
Günün sonunda kodları incelediğimde çok az kişinin uğraş verdiğini gördüm. Ben ise hayatımda hiç JUnit testleri yazmamıştım.
Kendi kendime bu iş başa düştü dedim. Tabiki Mehmet ve Nursel&amp;rsquo;e de (kendi ekibime) gelin başlayalım dedim.
Onların da işleri vardı. Saat akşam 8 civarıydı. Sen yaz sonra bize anlatırsın dediler.
Ben de oturdum, kendi test sınıfımı yazmaya başladım. Tüm sınıfın testini yapacaktım.
Fakat ekipteki arkadaşlar, &amp;ldquo;Tüm işi sen yaptın, bize bir iş bırakmadın.&amp;rdquo; dememeleri için kendi sınıfımı sürüm takip sistemine göndermedim.
Test sınıfını yazarken birçok hata düzelttim. Bunları gecenin 2sinde sürüm takip sistemine gönderdim.
Moralim bozulduğu için ayrıca ekipte bir sıkıntı çıkmasın diye başka iş almak istemedim.
Tabi bu konuda kampın son günü Hakan hocadan fırça da yedik.&lt;/p&gt;

&lt;p&gt;Yurttaki ortamımız da güzeldi. Oda arkadaşlarım ile güzel güzel sohbetler ettik, espriler yaptık.
Hatta ekip içerisindeki yaşadığım olayı onlara da anlattım baya bir güldük :)
Hepsine buradan çok teşekkür ederim onlardan çok şey öğrendim.
Bu arada öğrenci hayatım boyunca ilk defa bir yurtta kalmış oldum :)&lt;/p&gt;

&lt;p&gt;Başta yazılıma bakış açımı değiştiren Hakan Uygun ve kamp etkinliğini başlatan Mustafa Akgül hocamıza,
organizasyonda emeği geçen herkese, yaşadığım sorunlarla uğraşmaktan bıkmayan,
kurs içerisinde büyük sabır gösteren Deniz Korkmaz ve Umuthan Uyan&amp;rsquo;a,
özellikle kendi ekibimde ve beraber takıldığım Mehmet,
Sami ve Nursel&amp;rsquo;e bu güzel ortamı bana yaşattıkları için çok teşekkür ederim.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux Yaz Kampı - 1</title>
      <link>https://omerozkan.net/linux-yaz-kampi-1/</link>
      <pubDate>Thu, 28 Jun 2012 00:00:00 +0000</pubDate>
      
      <guid>https://omerozkan.net/linux-yaz-kampi-1/</guid>
      <description>&lt;p&gt;Fatih projesinde yapacağım staja başlamadan önce faydalı olması amacı ile Linux Yaz Kampı&amp;rsquo;nda Java EE eğitimine başvurmuştum.
Sonuç olumlu olunca İskenderun&amp;rsquo;dan Bolu&amp;rsquo;ya yolculuk başladı. Otobüste tanıştığım İsmail Abi ile sohbetlerimiz sayesinde yol daha az sıkıcı oldu.
12 saat yolun ardından İzzet Baysal Üniversitesi&amp;rsquo;ne ulaştım.&lt;/p&gt;

&lt;p&gt;Kampın ilk günü tanışma, neler yapılacak vs. ile geçti.
2. gün ise Java EE&amp;rsquo;na giriş yaptık. Dersi anlatan Hakan Uygun, JSP, JPA, Hibernate, JSF gibi konuları teorik olarak anlattı.
Daha sonraki günler EJB, Maven, JBoss Seam gibi teknolojiler hakkında bilgi sahibi olduk.
Proje geliştirme sürecinde kullanacağımız araçları, Git, Redmine, Sonar gibi uygulamaları inceledik.
Eğitimin ilk 4 günü bu şekilde geçti. Zend Framework ile çalıştığım MVC sistemi sayesinde bazı konuları kolayca anladım.
Aslına bakarsanız birçok konuyu güzel bir şekilde anlasam da Java EE mimarisini tam olarak kavrayamadım.
Umarım proje geliştirirken bütün bu soru işaretleri yok olur.&lt;/p&gt;

&lt;p&gt;Bolu hakkında da açıkçası beğendiğim tek şeyi iklimi oldu. Serin ve güzel bir havası var. Yaz için ideal bir şehir.
Fakat kampüs içinde yemekler gerçekten çok kötü. Zaten çok fazla alternatif yokç İnsanların damak tadı mı kötü bilemiyorum.
Üstelik yemekler bir hayli pahalı. Belki de Hatay gibi yemekleri çok güzel olan bir yerden geldiğim için de bana öyle gelmiş olabilir.
Bugün Abant gölüne gittik gezmek için. Piknik yapmak için güzel bir yer. Fakat baya sıkıldık.
Piknik yapmadığımız için 6 saat fazla geldi. Yemekleri üniversitedekilerden daha da pahalıydı.&lt;/p&gt;

&lt;p&gt;Java EE eğitimi ön muhasebe yazılımı geliştirme ile devam edeceğiz. Proje geliştirirken çevik yöntemler (Scrum) kullanacağız.
Umarım en iyi şekilde katkı sağlarım.&lt;/p&gt;

&lt;p&gt;Bolu ve kamp hakkında ilk izlenimlerim bunlar. Daha sonra yazmaya devam edeceğim.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>