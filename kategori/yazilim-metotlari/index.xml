<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yazilim Metotlari on Ömer Özkan</title>
    <link>https://omerozkan.net/kategori/yazilim-metotlari/</link>
    <description>Recent content in Yazilim Metotlari on Ömer Özkan</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>tr</language>
    <lastBuildDate>Fri, 03 Jun 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://omerozkan.net/kategori/yazilim-metotlari/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Java 8 Optional ve null dönebilen metotlar</title>
      <link>https://omerozkan.net/java-8-optional/</link>
      <pubDate>Fri, 03 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://omerozkan.net/java-8-optional/</guid>
      <description>&lt;p&gt;Merhabalar, bu yazıda sizlere Java 8 ile beraber gelen Optional sınıfından bahsedeceğim. Bu yazı ile birlikte Java
programlama dili ve teknolojileri konusunda ufak bilgiler paylaşmaya devam edeceğim. Umarım faydalı olur.&lt;/p&gt;

&lt;p&gt;Optional sınıfının kullanımına bir örnek vererek anlatacağım. Doğrudan anlatabilecek kadar basit bir sınıf olmasına rağmen
örnek üzerinden gitmenin daha kalıcı olduğunu düşünüyorum. Örneğimizde bir UserRepository sınıfı tasarlayacağız.
Interface&amp;rsquo;imiz şu şekilde:&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0ef7a9c175d40cdbea57ea72de25140e.js?file=userRepository1.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;UserRepository interface&amp;rsquo;inde &lt;code&gt;getByUsername()&lt;/code&gt; metodunun tanımlandığını görüyoruz. Adından da anlaşılacağı üzere kullanıcı
adı ile veritabanında kayıtlı bir kullanıcıyı bulmak istiyoruz. Basitçe aşağıdaki implementasyonu yapabiliriz.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0ef7a9c175d40cdbea57ea72de25140e.js?file=userRepositoryImpl1.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Herhangi bir persistent api kullanarak kullanıcı listesini aldık. Eğer liste boş dönerse girdiğimiz kullanıcı adına sahip
bir kullanıcı olmadığı anlamına geldiğinden &lt;code&gt;null&lt;/code&gt; object döndük. Eğer kullanıcı varsa listenin ilk elemanını dönüyoruz.
Kullandığınız api&amp;rsquo;nin ne olduğunun bir önemi yok. Bundan farklı bir implementasyonda olabilirdi. Burda dikkat etmemiz gereken
eğer veritabanında kullanıcı yoksa ne döneceğimiz. Bu tasarımda &lt;code&gt;null&lt;/code&gt; dönmüş olduk.&lt;/p&gt;

&lt;p&gt;Başlangıçta tasarım kusursuz görünse de &lt;code&gt;null&lt;/code&gt; dönmenin dezavantajları var. Bu sınıfı kullanan istemciye bir sorumluluk yükledik.
İstemci kullanıcıyı sorguladıktan sonra ayrıca bir de &lt;code&gt;null&lt;/code&gt;dönüp dönmediğini kontrol etmek zorunda. Aksi takdirde
NullPointerException&amp;rsquo;a sebep olur. Ayrıca bu aslında bir implementasyon detayı. İstemci açısından interface&amp;rsquo;e baktığınızda
aslında &lt;code&gt;null&lt;/code&gt; bir değer bekleyemeyiz. Basitçe bir metot var ve kullanıcı adı verip kullanıcı nesnesi alıyoruz. Yani interface
de &lt;code&gt;null&lt;/code&gt; obje gelebileceğine dair herhangi bir tanımlama yok. Javadoc veya yorum satırı mı geldi aklınıza? Burdaki javadoc
veya yorum satırı kötü koda sebep olur. Ayrıca kod açısından yine istemciyi bağlayan birşey yok. Bir diğer sorun ise null
dönülmesi bir implementasyon detayı. İmplementasyon yüzünden defensif programlama yapmak zorunda kalıyoruz.&lt;/p&gt;

&lt;p&gt;Burdaki durumda aslında kullanıcı nesnesinin &lt;code&gt;null&lt;/code&gt; gelebileceğini tahmin edebiliriz. Mantıken baktığınızda kullanıcı
veritabanında yoksa ne olur diye düşündüğünüzde &lt;code&gt;null&lt;/code&gt; dönebileceğini anlayabilirsiniz.
Fakat her durumda bu kadar basit bir durumda olmayabilir. Daha karmaşık bir implementasyonda istemci olarak bunu görmek
daha zordur. &lt;code&gt;null&lt;/code&gt; dönmek yerine exception kullanarak bir tasarım yapabiliriz:&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0ef7a9c175d40cdbea57ea72de25140e.js?file=userRepositoryImpl2.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;interface&amp;rsquo;i de şu şekilde değiştiriyoruz:&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0ef7a9c175d40cdbea57ea72de25140e.js?file=userRepository2.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Bu implementasyon yukarıda bahsettiğim sorunu çözüyor. Burada basit bir şekilde kullanıcı yoksa UserNotFoundException&amp;rsquo;u
fırlattık. Ayrıca checked exception olduğundan istemci bu metodu çağırırken exception&amp;rsquo;u handle etmek zorunda veya bir üst
katmana bırakabilir. Sonuç olarak implementasyona bakmadan interface bize exception fırlatabileceğini tanımlar.&lt;/p&gt;

&lt;p&gt;Bu tasarımın da yine dezavantajları var. İstemci taraf ya bir try-catch bloğu yazmak zorunda. Yani exception mekanizmasını
bir istisna durumu için değil normal akışın bir parçası olarak kullandık. Burada örneğin veritabanı bağlantısı kesilirse
exception atabilirdik veya istemci geçersiz bir kullanıcı adı gönderdiğinde IllegalArgumentException gibi bir exception
fırlatabilirdik. Fakat burdaki durum ne istemciye bağlı bir input hatası ne de beklenmeyen bir durum. O yüzden bu tarz
yapılarda Exception kullanmamalıyız.&lt;/p&gt;

&lt;p&gt;Çözüm olarak yine ilk tasarımımıza dönüp User entity&amp;rsquo;si dönmek yerine bir Result objesi dönebiliriz.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0ef7a9c175d40cdbea57ea72de25140e.js?file=userRepositoryImpl3.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;User entity&amp;rsquo;sini doğrudan dönmek yerine araya başka bir sınıf yerleştirerek ilk durumdaki sorunu çözmüş oluyoruz. Artık kullanıcının
veritabanında olmayacağını daha net bir şekilde ifade ettik. Bu tür Result sınıflarını immutable tanımlarsak daha iyi bir
tasarım yapmış oluruz. Constructor&amp;rsquo;lara isim veremediğimiz için burada static metod kullanmayı tercih ettim. UserResult sınıfı&amp;rsquo;da aşağıdaki gibi.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0ef7a9c175d40cdbea57ea72de25140e.js?file=userResult.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;İstemci taraf doesUserExist() metodu ile kontrol edip gereken işlemi yapabilir. Bu şekilde tasarımımız daha stabil oldu.
Àyrıca bunun büyük bir proje olacağını düşünürsek UserResult sınıfını daha generic olarak tasarlayabiliriz.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0ef7a9c175d40cdbea57ea72de25140e.js?file=entityResult.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;UserRepositoryImpl sınıfımızı da düzenleyelim.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0ef7a9c175d40cdbea57ea72de25140e.js?file=userRepositoryImpl4.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;EntityResult gibi result objeleri farklı implementasyonlar da içerebilir. Burda &lt;code&gt;null&lt;/code&gt;dönme problemini için kullandık.
Özellikle katmanlar arası iletişim bu şekilde yapılmalıdır.&lt;/p&gt;

&lt;p&gt;Java7 ile geliştirme yapsaydık eğer muhtemelen bu şekilde geliştirme yapacağız. Fakat Java 8 de bunun için &lt;code&gt;java.util&lt;/code&gt;
paketinin içerisinde &lt;code&gt;Optional&lt;/code&gt; diye bir sınıf eklendi. Kendi EntityResult gibi sınıflar yazmak yerine null dönebilen
metodlar için return type&amp;rsquo;ı Optional olarak tanımlayabiliriz.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0ef7a9c175d40cdbea57ea72de25140e.js?file=userRepositoryImpl5.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Optional yine tasarladığımız EntityResult gibi generic ve immutable bir sınıf. Yine &lt;code&gt;Optional.empty()&lt;/code&gt; aynı şekilde boş bir result dönüyor.
&lt;code&gt;null&lt;/code&gt; dönebilen yerlerde bunu kullanmalıyız. &lt;code&gt;Optional.of()&lt;/code&gt; metodunu da kullanırken dikkatli olmak gerekiyor. Eğer parametre
olarak verdiğiniz objenin değeri &lt;code&gt;null&lt;/code&gt; ise NullPointerException alırsınız. Eğer bir nesne &lt;code&gt;null&lt;/code&gt; olabilirse `Optional.ofNullable
metodunu kullanın. Diğer metodlarına da kısaca değinirsem:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;isPresent()&lt;/strong&gt; : eğer empty ise false diğer durumda true döner. İlk tasarımımızdaki null kontrolü yerine kullanılabilir.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;get()&lt;/strong&gt; : Empty olmayan durumlarda Optional içerisinde tanımlanan nesneyi döner. Mutlaka get den önce &lt;code&gt;isPresent()&lt;/code&gt; ile kontrol edilmesi
gerekiyor. Aksi takdirde değer empty ise NoSuchElementException alırsınız.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;orElse(T value)&lt;/strong&gt; : Eğer varsayılan bir değeriniz varsa kullanabilirsiniz. empty ise verdiğiniz değeri, değilse tanımlanan
değeri döner. Örneğin &lt;code&gt;null&lt;/code&gt; almak istiyorsanız &lt;code&gt;orElse(null)&lt;/code&gt; şeklinde nesneyi alabilirsiniz.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bunun gibi birçok metodu var. Aynı zamanda fonksiyonel özellikler de taşıyor. Java 8 ile beraber gelmesi bir raslantı değil :)
Dikkat etmeniz gereken başlangıçta metodları kullanırken mutlaka javadoc ile inceleyin. &lt;code&gt;get()&lt;/code&gt; metodunda olduğu gibi
exception alabilirsiniz. Ayrıca eğer Java 8 de Stream Api ile tanıştıysanız muhtemelen Optional sınıfını kullanmışsınızdır.
Stream Api&amp;rsquo;de oldukça fazla kullanılır. Primitive tipler için de &lt;code&gt;OptionalInt&lt;/code&gt;, &lt;code&gt;OptionalDouble&lt;/code&gt; gibi sınıfları da kullanabilirsiniz.&lt;/p&gt;

&lt;p&gt;Bu yazımda örnek bir tasarım ile Optional sınıfını anlatmaya çalıştım. Umarım faydalı olmuştur.&lt;/p&gt;

&lt;p&gt;Bir sonraki yazıda görüşmek üzere&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Test Güdümlü Geliştirmenin Etkileri</title>
      <link>https://omerozkan.net/test-gudumlu-gelistirmenin-etkileri/</link>
      <pubDate>Tue, 30 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>https://omerozkan.net/test-gudumlu-gelistirmenin-etkileri/</guid>
      <description>

&lt;p&gt;Test güdümlü yazılım geliştirme, öğrenmek istediğim en önemli konulardan biriydi.
Bu konuda JUnit in Action ve Test Driven Development By Example kitaplarını bitirdim. Özellikle Test Driven Development
By Example kitabı baya eğlenceli hem de bir o kadar öğretici bir kitaptı.
Kent Beck’in diğer kitaplarını okumak için can atıyorum. Daha önce de bu konu hakkında bir yazı paylaşmıştım.
Test güdümlü yazılım geliştirmenin faydaları, genelde duyduğum ve mantıken düşündüğümde kabul ettiğim faydalardı.
Ama birçoğunu kendi tecrübelerimde de yaşamış oldum. Yazılım geliştirmeyi seviyorsanız inanın TDD hayatınıza renk katacaktır.
TDD ile ilgili kendi tecrübelerim ve yaşadıklarımdan çıkardığım bazı özelliklerini yazacağım.&lt;/p&gt;

&lt;img class=&#34;ui right floated bordered medium image content-image&#34; src=&#34;https://omerozkan.net/images/post/tdd/development.jpg&#34;
     alt=&#34;TDD&amp;#39;nin development&amp;#39;ı kolaylaştırması&#34; /&gt;

&lt;h3 id=&#34;daha-kolay-geliştirme:7b6d2cd657f12b2a7c8ff451369c4d79&#34;&gt;Daha Kolay Geliştirme&lt;/h3&gt;

&lt;p&gt;TDD ile  bilinmesi gereken en önemli konulardan birisi asıl amacın test etmek olmadığıdır. Test etmek sadece bunun bir parçasıdır.
Bununla beraber birçok avantajları beraberinde getirir. Dikkatimi çeken ilk şey yazılım geliştirmeyi kolaylaştırmasıydı.
Çünkü aşama aşama kod yazıyorsunuz. Örneğin bir sınıf yazdığınızı düşünelim. Bu sınıftan beklentilerinizin bir listesini çıkarıyorsunuz.
Tabi daha sonra bu listede ekle/sil yapabilirsiniz. Listedeki bazı beklentilerin çözümü karmaşık bazıları ise çok açıktır.
Daha sonra listeye bakıp en kolay en rahat yapabileceğiniz birini seçip birim testi oluşturuyorsunuz.
Zaten en kolayını seçtiğiniz için implementasyonu da kolay olacaktır.
Daha sonra listeden farklı bir beklentiyi seçip yine aynı şekilde gerçekleştiriyorsunuz.
Daha karmaşık beklentiler  ise gittikçe daha da kolaylaşacak ve çözümleri daha açık hale gelmeye başlayacaktır.
Aşama aşama gittiğiniz için sadece tek bir sorunu düşünürsünüz. Aynı zamanda kendinizi de planlamış olursunuz.
Bu sayede zaman da kazanırsınız ve söylediğim gibi karmaşık çözümleri de daha kolay bulmanızı sağlayacaktır.
Bu özelliğinden dolayı yazılım geliştirmeyi daha da kolaylaştırır.&lt;/p&gt;

&lt;img class=&#34;ui left floated bordered medium image content-image&#34; src=&#34;https://omerozkan.net/images/post/tdd/tdd_cycle.jpg&#34;
     alt=&#34;Test güdümlü geliştirme hayat döngüsü&#34; /&gt;

&lt;h3 id=&#34;refactoring:7b6d2cd657f12b2a7c8ff451369c4d79&#34;&gt;Refactoring&lt;/h3&gt;

&lt;p&gt;Önce bir test yazarsınız. O test doğal olarak olumlu sonuç vermez. Yani testleriniz kırmızıdır.
Testleri yeşile çevirmek için olabilecek en basit çözümü uygularsınız ve testler yeşile döner.
Yeşil aslında size güvence verir.
Daha sonra testin yeşil olmasından daha da cesaret alarak kodlarınızı düzenleyip en uygun implementasyonu gerçekleştirirsiniz.
Sonra tekrar bakarsınız yine yeşil ise bir sonraki teste geçersiniz.
Eğer kırmızı ise ve sorunu çözemiyorsanız hemen yaptığınız değişiklikleri geri alarak tekrar yeşile dönüp
başka bir şekilde implementasyon yapabilirsiniz.
Ayrıca her aşamanın sonunda kodlarınızın temiz olup olmadığını kontrol edersiniz.
Örneğin DRY prensibine uygun değilse ona göre refactor edebilirsiniz.
Veya yazdığınız bir algoritmanın daha performanslı çalışacağını düşünüp rahatça değişiklik yapabilirsiniz.
Refactor sonunda kodlarınızın dış davranışını bozarsanız testleri çalıştırarak rahatça anlayabilir ona göre davranabilirsiniz.
Testlerin hepsini gerçekleştirdikten sonra da kodun bakımını yapabilirsiniz fakat bu işinizi daha da zorlaştırır
veya daha kötü kodlar yazmanıza sebep olabilir. O yüzden her testten sonra kod bakımı yapmak daha uygundur.
Bu sayede sonraki aşama için temiz bir ortam sunarsınız. (Kırık cam prensibi)&lt;/p&gt;

&lt;h3 id=&#34;daha-düzenli-ve-temiz-kodlama:7b6d2cd657f12b2a7c8ff451369c4d79&#34;&gt;Daha Düzenli ve Temiz Kodlama&lt;/h3&gt;

&lt;p&gt;MVC öğrenmek için geliştirdiğim küçük bir php uygulama çatısı vardı: Çizgi.
Çizgi’yi tekrardan test güdümlü yazılım ile geliştirmek istedim.
Sebebi ise öğrendiğim teorik konuları uygulayarak TDD tecrübesi kazanmaktı.
Ayrıca TDD’yi sürekli Java ile öğrendiğim için başka bir programlama dili ile de uygulamanın faydalı olacağını düşündüm.
Geliştirirken dikkatimi çeken en önemli faydası temiz kodlar yazmak oldu. Eski kodlarıma baktığımda ne kadar kötü yazdığımı gördüm.
Tabiki artı 1 yıllık çalıştığım konuların, edindiğim tecrübelerin de etkisi var.
Fakat yazdığım kötü kodları testi tamamladıktan sonra daha okunabilir hale getirdim.
Bu da herşeyin sonucunda eskisine göre daha güzel kod yazmama sebep oldu.&lt;/p&gt;

&lt;h3 id=&#34;esneklik:7b6d2cd657f12b2a7c8ff451369c4d79&#34;&gt;Esneklik&lt;/h3&gt;

&lt;p&gt;Dikkat ettiğim diğer faydası ise esnekliğe katkıda bulunmasıydı.
Tasarım şablonları konusunda fazla tecrübeli olmasam bile TDD sayesinde esnek olma konusunda daha iyi geliştirme yaptığımı farkettim.
Birim testler ile bir sınıfı test ederken diğer sınıflardan bağımsız halde test etmeniz gerekiyor.
Bu da size mecburen esnek yapılar oluşturmanızı sağlamış oluyor.
Örneğin birçok yerde &lt;a href=&#34;http://en.wikipedia.org/wiki/Inversion_of_control&#34;&gt;“Inversion of Control”&lt;/a&gt; şablonunu uygulamak zorunda kaldım.
Tabiki bu konuda çok yeterli olduğumu düşünmesem de ilerde tasarım prensipleri ve şablonlara daha iyi hakim olduğumda bununla beraber
TDD ile gerçekten güzel işler çıkartabileceğimi düşünüyorum.&lt;/p&gt;

&lt;p&gt;Çizgi’nin bir sınıfını geliştirirken birkaç metod yazmıştım ki birşey farkettim.
Yazdığım metodlar tanımladığım sınıfın asıl yapması gerekenler değildi.
Hatta o sınıfın başka bir işi daha yaptığını ve bir sorumluluk daha yüklediğimi farkettim.
Bu da önemli prensiplerden birini “Single Responsibility” yani “Tek Sorumluluk” prensibini daha önce defalarca ihlal ettiğim anlamına geliyordu.
Tek sorumluluk prensibi yazdığınız bir sınıfın sadece ve sadece bir tek sorumluluğu olması gerektiğini belirtir.
Eğer birden fazla sorumluluk yüklerseniz o sınıfın kırılması için birden fazla sebep yükleyeceksiniz.
Aynı şekilde o sınıfın nesnelerini kullanan diğer sınıflar ise bundan kolayca etkilenecek ve
bu yüzden bir değişiklik yaptığınızda fazladan düzeltmeler yapmış olacaksınız.
Bu prensibe uymak için hemen yeni bir sınıf oluşturup, metodları o sınıfa taşıdım.
TDD esnek yapılar oluşturmama büyük ölçüde katkı sağlıyordu.&lt;/p&gt;

&lt;h3 id=&#34;daha-az-hata-ayıklama:7b6d2cd657f12b2a7c8ff451369c4d79&#34;&gt;Daha Az Hata Ayıklama&lt;/h3&gt;

&lt;p&gt;TDD’nin bana diğer katkısı da tabiki de doğru çalışan sınıflar yazmış olmamdı.
Bir php projesinin büyük bir kısmını herhangi bir sunucu uygulamasını (Apache, Lighthttp vs) çalıştırmadan geliştirdim.
PhpUnit sayesinde yazdığım kodların doğru çalıştığını biliyordum.
Daha sonra uygulamayı gerçek ortamda yani Apache sunucu da çalıştırdığımda gerçekten olumlu sonuç aldım.
Eskiden geliştirdiğimde yazdığım kodun bir de hata ayıklaması ile uğraşırdım.
Eğer debugging yapmayı sevmiyorsanız ki bunu sevenin çok olduğunu düşünmüyorum, TDD tam size göre.
TDD sayesinde daha az debugging (hata ayıklama) yaparsınız.
Çünkü TDD ile hem aşama aşama hem de önce testleri yazdığınız ve çalışmasını sağladığınız için birçok hatayı önlemiş olursunuz.
Bu da uygulamanızın daha az hata ayıklama ile çalışmasını sağlar. Bu arada birim testleri (unit test) tek başına yeterli değildir.
Mutlaka entegrasyon testlerinin ve diğer test konseptlerinin de uygulanması gerekir.
Çünkü yukarda bahsettiğim gibi birim testler diğer sınıflardan bağımsız şekilde yapılmalıdır.
Fakat sistemi entegre ettiğinizde doğru çalışacağının garantisini vermez.
Bu yüzden entegrasyon ve diğer test konseptlerinin de uygulanması gereklidir. Ama birim testler birçok hatayı başlangıçta önler.&lt;/p&gt;

&lt;h3 id=&#34;hızlı-sonuç:7b6d2cd657f12b2a7c8ff451369c4d79&#34;&gt;Hızlı Sonuç&lt;/h3&gt;

&lt;p&gt;Birim testlerinin en önemli avantajı ise sunucu dışında ve diğer servislerden bağımsız çalışabilmesidir.
Bu da sizin uygulamayı hızlıca test etmenizi sağlar. Bu php projeleri için pek sorun olmayabilir.
Çünkü php derleme gerektirmeyen, sunucu içerisinde bir dosyada değişiklik yapıp kaydettiğinizde hızlıca sonucunu görebileceğiniz bir teknolojidir.
Fakat Java ve özellikle kurumsal projelerde bu sizin için büyük sorun olabilir.&lt;/p&gt;

&lt;h3 id=&#34;katalar:7b6d2cd657f12b2a7c8ff451369c4d79&#34;&gt;Katalar&lt;/h3&gt;

&lt;p&gt;Test güdümlü yazılım geliştirme ile ilgili kitaplarla beraber kataların da oldukça önemi vardır.
Katalar size pratik yapmayı sağlar. Kataları özellikle TDD ile yaparsanız, birçok konuda öğrendiklerinizi tazelemiş olursunuz.
Ayrıca kullandığınız geliştirme araçlarına da hakim olmanızı sağlar.
Katalara ilk başladığımda bana bu kadar fayda sağlayacağını düşünmemiştim.
Birçok usta yazılımcı her gün düzenli olarak kata yapar. TDD’ye başlamak istiyorsanız katalar ile başlayabilirsiniz.&lt;/p&gt;

&lt;p&gt;Test güdümlü yazılım ile yazılım geliştirmeyi daha çok sevmeye başladım. Çünkü gerçekten daha zevkli bir hale getiriyor.
TDD birçok sorunu gölgede bıraktığı için de geliştirmekten daha çok zevk almanızı sağlıyor.&lt;/p&gt;

&lt;p&gt;Başka bir yazıda görüşmek üzere&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OOP: Polimorfizm</title>
      <link>https://omerozkan.net/oop-polimorfizm/</link>
      <pubDate>Tue, 13 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>https://omerozkan.net/oop-polimorfizm/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://omerozkan.net/oop-kapsulleme/&#34;&gt;Kapsülleme&lt;/a&gt; ve &lt;a href=&#34;https://omerozkan.net/oop-kalitim/&#34;&gt;kalıtım&lt;/a&gt; konularından sonra sıra geldi polimorfizme.
Polimorfizm, Türkçe&amp;rsquo;de çok biçimlilik olarak çevriliyor.
Polimorfizmi anlatmak için JUnit in Action kitabında gördüğüm güzel bir örneği vereceğim.
Bu örnek sayesinde polimorfizm&amp;rsquo;in kullanım amacını da göstermiş olacağım. Örnek göstererek anlatmayı daha uygun buldum.
Ben önce örnekleri inceleyip sonra açıklamaları okurdum. Bu sayede daha kolay kavrıyorum.
Aynı yöntemi burda da uygulayacağım. Bu konuyu kavramanız için kalıtım konusuna hakim olmanız gerekmektedir.&lt;/p&gt;

&lt;p&gt;Örneğimizde bir yazıcımız var. Bu yazıcı kelime işlemci ve pdf belgelerini basabiliyor.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=pdf1.java&#34;&gt;&lt;/script&gt;
&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=word1.java&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;PDF ve Word sınıfları getPrintableText() isimli bir metodu içeriyor. Şimdi de yazıcı (Printer) sınıfımıza bakalım.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=printer1.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Printer sınıfımızın ise iki metodu var. printPDF metodu PDF dökümanını, printWord metodu ise word dökümanını yazdırıyor.
Bu metodlar bu nesneleri parametre olarak alıp, PDF ve Word sınıflarının getPrintableText metodunu kullanarak ekrana yazabiliyor.&lt;/p&gt;

&lt;p&gt;Bu tasarım başlangıçta güzel gözükse de aslında bir çok problemi beraberinde getiriyor. &lt;strong&gt;printPDF&lt;/strong&gt; ve &lt;strong&gt;printWord&lt;/strong&gt; metotları
nerdeyse birbirinin aynısı. Yani duplicated kod barındırıyor. Diğer bir problem diyelim ki müşteriniz Excel tablolarını
da yazdırmak istedi. Ne yapmanız gerekiyor. Öncelikle bir Excel sınıfı ekleyip ardından &lt;strong&gt;Printer&lt;/strong&gt; sınıfına &lt;strong&gt;printExcel()&lt;/strong&gt; adlı
yine aynı işi yapan bir metot eklemeniz gerekiyor. Bu sefer üç tane metod aynı işi yapmış olacak. Yer yeni bir belge türü
eklediğimizde Printer sınıfını sürekli değiştirmemiz gerekiyor. Bu durum Open-Close (Açık-Kapalı) prensibine aykırı bir durum.
Open-Close prensibi yazdığımız sınıfların gelişime açık fakat değişime kapalı olması gerektiğini tanımlar. Bu durumu
polimorfizm ile düzeltebiliriz.&lt;/p&gt;

&lt;p&gt;Öncelikle daha önceden öğrendiğimiz kalıtımı(yemek tarifi gibi oldu :)) kullanarak sınıflarımızı yeniden yapılandıralım.
&lt;strong&gt;PDF&lt;/strong&gt; sınıfıda &lt;strong&gt;Word&lt;/strong&gt; sınıfıda aslında birer belge yani &lt;strong&gt;Document&lt;/strong&gt; özelliğini taşıyor.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=document.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Şimdi Word ve PDF sınıflarını Document sınıfını &lt;strong&gt;extend&lt;/strong&gt; edebilir.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=word2.java&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=pdf2.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Override anotasyonunu (annotation) görüyorsunuz. Anotasyonlar Java 1.5&amp;rsquo;ten sonra gelen bir özelliktir.
Buradaki Override anotasyonu, Word ve PDF&amp;rsquo;te bulunan getPrintableText metodlarının ata sınıfın (Document) print metodunun değiştirildiği anlamına gelir.&lt;/p&gt;

&lt;p&gt;Şimdi &lt;strong&gt;Printer&lt;/strong&gt; sınıfını da yeniden düzenleyelim.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=printer2.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Şimdi daha iyi anlamanız için bir test sınıfı yazalım.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=printerTest.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Eğer sonucu görmediyseniz lütfen sonucu tahmin etmeye çalışın.&lt;/p&gt;

&lt;p&gt;Bu kodun ekran çıktısı aşağıdaki gibi olacaktır.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;This is a document&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;This is a PDF document&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;This is a Word document&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;4. satırda yeni bir yazıcı sınıfı ürettik.
6. satırda bir döküman nesnesini yazdırdık. Beklediğimiz gibi Document sınıfında tanımladığımız metni yazdırdı.
8. satırda ise bir pdf belgesini yazdırmak istedik. Printer sınıfının parametre referans tipine baktığınızda Document olduğunu
görüyorsunuz. PDF de bir document nesnesi olduğu için bu nesneyi bu metoda geçirebildik(passing). Bu polimorfizmin birinci
durumu. Yani Document sınıfını extend eden herhangi bir nesneyi Document referansı ile kullabiliriz. Bunu şu şekilde de
tanımlayabilirdik.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Document document = new PDF()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Yani Document dışında farklı sınıfların nesnelerini de Document referansı ile tanımlayabiliriz. Bunu polimorfizm sağlar.
Polimorfizmin sağladı diğer bir güzellik ise ekranda gördüğünüz &amp;ldquo;This is a PDF document&amp;rdquo; yazısıdır. Document sınıfında
tanımlanan varsayılan davranış yerine PDF sınıfında bu davranışı değiştirerek farklı metin yazmasına sebep olduk. Bu şekilde
her nesnenin bir metod veya herhangi bir interface(java&amp;rsquo;daki interface&amp;rsquo;leri kastetmiyorum) için farklı davranış göstermesine &lt;strong&gt;polimorfizm&lt;/strong&gt; diyoruz.&lt;/p&gt;

&lt;p&gt;10. satırda aynı durum Word sınıfı için geçerli. Ayrıca Printer sınıfının tek bağımlılığı Document sınıfına oldu. Yani
Printer ve Document sınıfını bir jar içerisinde müşteriye teslim edebiliriz. Bu da bize esnek bir yapı sağlar.&lt;/p&gt;

&lt;p&gt;Şimdi gelelim müşterinin isteğine, müşteri bir Excel dosyası yazdırmak istemişti. Artık Printer sınıfına dokunmamıza bile gerek yok.
Yeni bir Excel sınıfı ekleyelim.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=excel.java&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;super-anahtar-kelimesi:1e4f0b0da4b93aa40114849c5b8e437e&#34;&gt;super anahtar kelimesi&lt;/h3&gt;

&lt;p&gt;Java&amp;rsquo;da nesneyi üst sınıfın interface i ile kullanmak isterseniz. &lt;code&gt;super&lt;/code&gt; anahtar kelisini (keyword) kullanabilirsiniz.
Örneğimize bakarsak PDF sınıfı Document&amp;rsquo;in print metodunun üzerine kendi &lt;strong&gt;getPrintableText()&lt;/strong&gt; metodunu deği davranışını
değiştirmiş oldu ve Document sınıfında tanımlanan print metodunun davranışını iptal etti.
Peki PDF sınıfı atasından (Document) aldığı &lt;strong&gt;getPrintableText()&lt;/strong&gt; metodunu kullanmak isterse ne yapmalıyız?
İşte burda super anahtar kelimesini kullanabiliriz. PDF sınıfını aşağıdaki şekilde değiştirelim.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/753829850b1fd08184d3.js?file=pdf3.java&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Bunun sonucunda &lt;strong&gt;getPrintableText()&lt;/strong&gt; metodu &amp;ldquo;This is a document\nThis is a PDF document\n&amp;rdquo; değerlerini döndermiş olur.&lt;/p&gt;

&lt;p&gt;Polimorfizm kavrami OOP&amp;rsquo;ye özgür bir özellik değildir. OOP ile uygulanabilir.&lt;/p&gt;

&lt;p&gt;Bu yazımda polimorfizmi yüzeysel olarak anlatmaya çalıştım. Umarım faydalı olmuştur.&lt;/p&gt;

&lt;p&gt;Bir sonraki yazıda görüşmek üzere&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OOP: Kalıtım</title>
      <link>https://omerozkan.net/oop-kalitim/</link>
      <pubDate>Sat, 03 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>https://omerozkan.net/oop-kalitim/</guid>
      <description>&lt;p&gt;Bir önceki yazımda OOP konusuna giriş yapmış ve kapsüllemeyi anlatmıştım.
Bu yazımda ise &amp;ldquo;Kalıtım&amp;rdquo; konusundan bahsetmek istiyorum.
Kalıtım (inheritance) kelimesi aslında biyolojide anlamı ile aynıdır.
Adından da anlaşılacağı gibi bir sınıfın özelliklerini diğer sınıfa olduğu gibi aktarmasıdır.&lt;/p&gt;

&lt;p&gt;Peki böyle bir özelliğe neden ihtiyaç duyarız.
Bir üniversitedeki öğretim görevlilerini ve öğrencileri modelleyen iki sınıf tanımlayalım.
Öğrenci sınıfı öğrencinin adını, soyadını, okul numarasını, T.C. kimlik numarasını, bölümünü içersin.
Öğretim görevlisi sınıfı ise öğretim görevlisinin adını, soyadını, hangi bölümün kadrosunda yer aldığını,
T.C. kimlik numarasını ve akademik ünvanını içersin. Bunu Java kodları ile ifade edersek:&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/84daffabbbc96abca820.js?file=lecturer1.java&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/84daffabbbc96abca820.js?file=student1.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Student&lt;/strong&gt; ve &lt;strong&gt;Lecturer&lt;/strong&gt; adında Java sınıflarımız var.
Bu sınıflar gördüğünüz gibi basit bir şekilde getter ve setter metodlarından oluşuyor.
Bu iki sınıf arasındaki benzerlikleri düşünelim. id (T.C. Kimlik No) , name, surname, department değerleri aynı.
Örneğin bir de üniversitede çalışan memurları modellersek yine aynı verileri tekrarlamak zorundayız. Bu da tekrarlı koda (duplicated code)
sebep olur. Bu durum &lt;strong&gt;DRY (Don&amp;rsquo;t Repeat Yourself)&lt;/strong&gt; prensibine aykırı.&lt;/p&gt;

&lt;p&gt;Bu sorunu kalıtım (inheritance) kullanarak çözebiliriz. Bunun için öncelikle Person adlı bir sınıf tanımlıyoruz ve bu sınıfa
&lt;strong&gt;Lecturer&lt;/strong&gt; ve &lt;strong&gt;Student&lt;/strong&gt; sınıfların ortak özelliklerini yerleştiriyoruz.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/84daffabbbc96abca820.js?file=person.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Gördüğünüz gibi Person sınıfımız önceki tanımladığımızın iki sınıfın özelliklerini içeriyor.
Burada dikkat ederseniz bölümü eklemedim. Bunun sebebi uygulamamıza ekleyeceğimiz diğer personeller herhangi bir bölümde olmayabilirler.
Ama her personelin T.C kimlik numarası, adı ve soyadı olmak zorunda.
Student ve Lecturer sınıflarını aşağıdaki gibi değiştirebiliriz.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/84daffabbbc96abca820.js?file=lecturer2.java&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/84daffabbbc96abca820.js?file=student2.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Student ve Lecturer sınıflarının tanımlarına dikkat edersek &lt;strong&gt;extends Person&lt;/strong&gt; ifadesini görüyoruz.
Java&amp;rsquo;da kalıtım &lt;strong&gt;extends&lt;/strong&gt; anahtar kelimesi ile yapılır.
Kalıtım ile Person sınıfının bütün özelliklerine hem Student hem de Lecturer sınıfı sahip oldu.
Yani Student ve Lecturer sınıfı da id, name, surname alanlarına ve getter/setter metodlarına sahip.
Bu sayede kod tekrarından kurtulmuş olduk.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Not:&lt;/strong&gt; Önceki yazımda erişim belirleyicilerinden bahsetmiştim.
private ile tanımlanan metodlar veya alanlara sınıf dışından erişilemez.
Burada name, surname ve id alanlarına direkt olarak erişemeyiz.
Fakat public olan getter ve setter metodları sayesinde bu değişkenlere erişmemiz mümkün.
Sadece genişletilen (türetilen) sınıflardan (Student ve Lecturer) erişmek isteseydik name, surname ve id alanlarını
 &lt;strong&gt;protected&lt;/strong&gt; erişim belirleyicisi ile tanımlamamız yeterli olacaktır.
 &lt;strong&gt;protected&lt;/strong&gt; ile tanımlanan alanlar ve metodlar aynı zamanda aynı paket içerisindeki diğer sınıflar tarafından da erişilebilir.&lt;/p&gt;

&lt;p&gt;Kalıtımın diğer sağladığı bir özellik OOP&amp;rsquo;de polimorfizme imkan sağlamasıdır. Bunun için &lt;a href=&#34;https://omerozkan.net/oop-polimorfizm/&#34;&gt;OOP: Polimorfizm yazısını&lt;/a&gt; okuyabilirsiniz.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OOP: Kapsülleme</title>
      <link>https://omerozkan.net/oop-kapsulleme/</link>
      <pubDate>Fri, 02 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>https://omerozkan.net/oop-kapsulleme/</guid>
      <description>

&lt;p&gt;Blogumda yazılım ile ilgili pek bir yazı olmadığından artık bazı konularda yazılar yazmaya karar verdim.
Bu yüzden programlamanın en temel ve en önemli konularından biri olan Nesne Yönelimli Programlama&amp;rsquo;yı elimden geldiği kadar anlatmaya çalışacağım.
Object Oriented Programming bir programlama yaklaşımıdır. Nesneye yönelik programlama, nesneye dayalı programlama,
nesne tabanlı programlama, nesne esaslı programlama gibi bir çok çevirisi vardır. Ben de Türkçe de daha çok yaygın olan nesne
yönelimli programlamayı kullanıyorum. Fakat genelde bahsederken OOP olarak kısaltacağım.&lt;/p&gt;

&lt;p&gt;Yazılım gereksinimleri arttıkça prosedürel programlama bir çok sorunu beraberinde getiriyordu.
Bu sorunlara kod karmaşıklığının artması, bakımın oldukça zor olması, ekip halinde çalışmayı zorlaştırması,
maliyetlerin artması örnek olarak verilebilir. Bütün bu sorunların sonucu olarak da &amp;ldquo;Nesne Yönelimli Programlama&amp;rdquo; ortaya çıkmıştır.
OOP ilk olarak 60&amp;rsquo;lı yıllarda Norveç&amp;rsquo;te geliştirilen &lt;strong&gt;&amp;ldquo;Simula&amp;rdquo;&lt;/strong&gt; programlama dili ile ortaya çıkmıştır. Simula ise &lt;strong&gt;ALGOL&lt;/strong&gt; tabanlı
bir programlama dilidir. Günümüzde hemen hemen bütün modern diller OOP desteklemektedir. OOP&amp;rsquo;nin bu kadar popüler olmasının
bir sebebi var. Merak edenler için &amp;ldquo;SOLID&amp;rdquo; anahtar kelimesini vereyim.
Fakat bu yazı dizisinde OOP&amp;rsquo;nin en temel özelliklerini anlatacağım.
OOP&amp;rsquo;yi anlatırken Java&amp;rsquo;da sınıflar ve nesneler konusunda bilgi sahibi olduğunuzu varsayacağım.&lt;/p&gt;

&lt;p&gt;OOP denilince akla üç (bazı kaynaklara göre dört) özellik geliyor. Bunlar:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Encapsulation (Kapsülleme)&lt;/li&gt;
&lt;li&gt;Inheritance (Kalıtım)&lt;/li&gt;
&lt;li&gt;Polymorphism (Polimorfizm veya Çok biçimlilik)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bazı kaynaklar Abstraction (Soyutlama)&amp;lsquo;ı da dahil etmektedir. Daha önce ben de bu şekilde tanımlardım.
Soyutlama ise çok daha geniş bir konu olduğundan üç özellik olarak tanımlamayı tercih ediyorum. Bu yazı dizisinde
soyutlamaya da yer vereceğim.&lt;/p&gt;

&lt;h2 id=&#34;encapsulation-kapsülleme:ec6c8a1cc144b0e8e50636ff4e409a35&#34;&gt;Encapsulation (Kapsülleme)&lt;/h2&gt;

&lt;p&gt;Kapsülleme de aslında bir çok şekilde yapılabilir. Fakat basit olması amacı ile en kolay yönden tanımlayacağım.&lt;/p&gt;

&lt;p&gt;Kapsüllemeyi kısaca tanımlarsak bir nesnenin iç yapısını (verilerini ve özelliklerini) dış dünyadan doğrudan erişime kapatılması anlamına gelir.
Bu sayede nesneye ait veriler değer ataması yapılırken yanlış kullanımdan korunmuş olur. İç yapısının dışarıya açık olmaması
aynı zamanda iç yapı ile ilgili değişikliklerin dış dünyanın etkilenmemesini de sağlamış olur. Bu açıdan çok önemlidir.&lt;/p&gt;

&lt;p&gt;Java programlama dilinde nesne elemanlarının dışarıya kapatılması için &lt;strong&gt;private&lt;/strong&gt; erişim belirteci kullanılır.
Java&amp;rsquo;da dört &lt;em&gt;erişim belirleyicisi (access modifier)&lt;/em&gt; vardır. Bunları kısaca tanımlarsak:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;public&lt;/strong&gt;: public kelimesi halka açık veya kamu anlamına gelmektedir.
Bu erişim belirleyicisi ile tanımlanan herşey diğer bütün sınıflar tarafından erişilebilir.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;private&lt;/strong&gt;: özel veya gizli anlamına gelir.
Bu erişim belirleyicisi ile tanımlanan herhangi bir eleman sadece ve sadece aynı sınıf içerisinden erişilebilir. Yani diğer sınıflar
hiç bir şekilde erişemez.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;package-private&lt;/strong&gt;: Adı üstünde paket anlamına gelir. Bu erişim belirleyicisi ile işaretlenen herşey sadece ve sadece
aynı paket içerisinde tanımlanan sınıflar tarafından erişilebilir. Farklı paketlerde bulunan sınıflar erişemez.
Java&amp;rsquo;da değişkenleri, metodları vs. diğer erişim belirleyicisilerle tanımlamazsanız, &lt;em&gt;package-private&lt;/em&gt; olarak tanımlamış
olursunuz. Yani package veya package-private gibi kelimeler kullanılmaz.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;protected&lt;/strong&gt;: Korumalı anlamına gelir. Bu erişim belirleyicisi ile herhangi bir eleman türetilmiş olan ve aynı paket içerisinde olan sınıflar içerisinden erişilebilir.
(Kalıtım konusunda anlatılacaktır.)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bunlara kullanarak örnek bir sınıf tasarlayalım.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0e06db9d134e6d5699ba.js?file=accessModifierTest.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Payı (numerator) ve paydası (denominator) olan basit bir Rational (rasyonel) sınıfı tanımlayalım.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0e06db9d134e6d5699ba.js?file=rational.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Bu sınıfın iki değişkeni var: &lt;strong&gt;&lt;em&gt;numerator&lt;/em&gt;&lt;/strong&gt; ve &lt;strong&gt;&lt;em&gt;denominator&lt;/em&gt;&lt;/strong&gt;.
Bu iki değişken sınıfa ait olduğu için alan (field) olarak tanımlayabiliriz.
Bu iki alanın erişim belirleyicisini &lt;strong&gt;private&lt;/strong&gt; olarak belirledik.
Bu sayede sınıf dışından erişimi kapatmış olduk.
Örneğin başka bir sınıftan aşağıdaki gibi bir kullanım hatalı olacaktır.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0e06db9d134e6d5699ba.js?file=rationalClient.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Ayrıca dikkatlice incelerseniz &lt;strong&gt;&lt;em&gt;Rational&lt;/em&gt;&lt;/strong&gt; sınıfında &lt;strong&gt;&lt;em&gt;IllegalDenominator&lt;/em&gt;&lt;/strong&gt; sınıfı da tanımlanmış. Bu tür sınıflara
&lt;strong&gt;inner-class&lt;/strong&gt; diyoruz. Bu sınıfında bir erişim belirteci var. public olması sebebi ile bu sınıfa dışarıdan herkes erişebilir.&lt;/p&gt;

&lt;p&gt;Rational sınıfına dikkat ederseniz getter ve setter metodlarımnız var (Örneğin: getNumerator(), setNumerator()).
Bu metodların erişim belirleyicisi de &lt;strong&gt;&lt;em&gt;public&lt;/em&gt;&lt;/strong&gt; yani dışardan erişime açık.
Bu sayede numerator ve denominator değişkenlerine bu metodlar aracılığı ile değer atanabilir. Aşağıdaki kullanım doğru olacaktır.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0e06db9d134e6d5699ba.js?file=rationalClient2.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;setNumerator&lt;/em&gt;&lt;/strong&gt; ve &lt;strong&gt;&lt;em&gt;setDenominator&lt;/em&gt;&lt;/strong&gt; sayesinde numerator ve denominator değişkenlerine değer atanmış oldu.
Burada gördüğünüz set ile başlayan metodlara &lt;strong&gt;setter&lt;/strong&gt; adı verilir.
Aynı şekilde bu alanların değerlerine erişmek için &lt;strong&gt;&lt;em&gt;getNumerator&lt;/em&gt;&lt;/strong&gt; ve &lt;strong&gt;&lt;em&gt;getDenominator&lt;/em&gt;&lt;/strong&gt; metodlarını kullanabiliriz.
Bu şekilde tanımlanan metodlara da &lt;strong&gt;getter&lt;/strong&gt; adı verilir.&lt;/p&gt;

&lt;p&gt;setDenominator metodunu detaylı inceleyelim. 15. satırda bir koşul olduğunu görüyorsunuz.
Eğer denominator&amp;rsquo;e yani paydaya 0 değeri atanmaya çalışıldığında,
bu metod Exception fırlatarak paydanın 0 olmasını engellemiş oluyor.
Bu sayede yanlış kullanımı engellemiş olduk. Bu sayede veri bütünlüğü ve kontrolü sağlanmış oldu.
Genelde bütün alanlar geçerli bir sebep olmadıkça private olarak tanımlanır. Yani dışarıya kapatılmalıdır.
Her alan için getter ve setter metodları tanımlamak zorundayız diye de düşünmeyin.
Böyle bir zorunluluk yok. getter ve setter metodlar olmadan farklı metodlar aracılığı ile de erişimi kontrol altına alabilirsiniz.
Örneğin sınıfımıza 3 tane constructor metod ekleyelim.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/0e06db9d134e6d5699ba.js?file=rational2.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Bu tasarımımız da farklı bir örnek oldu. Dikkat ederseniz bu tasarımımızda setter metodları kaldırdık.
Bu sınıfı kullanan istemci artık sadece nesne üretirkendeğerleri verebilecek nesne üretildikten sonra değerini değiştiremeyecektir.
nominator ve denominator değişkenleriniprivate olarak tanımladığımız için istemcinin doğrudan ne de dolaylı olarak
değerini değiştiremez. Bu tarz sınıflara &lt;strong&gt;immutable&lt;/strong&gt; sınıf adı verilir.&lt;/p&gt;

&lt;p&gt;Bu yazıda kısaca encapsulation yani kapsüllemeyi anlattım. Bir sonraki yazıda görüşmek üzere&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Test Güdümlü Yazılım Geliştirmeye Merhaba</title>
      <link>https://omerozkan.net/test-gudumlu-yazilim-gelistirmeye-merhaba/</link>
      <pubDate>Fri, 12 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>https://omerozkan.net/test-gudumlu-yazilim-gelistirmeye-merhaba/</guid>
      <description>&lt;p&gt;&amp;ldquo;Test Driven Development&amp;rdquo; yani Türkçe söylersem &amp;ldquo;Test Güdümlü Yazılım Geliştirme&amp;rdquo; ile birkaç ay öncesinde tanıştım.
Fakat bu konuda halen öğrenmeye devam ediyorum. Bu konuda bildiğim temel bilgileri paylaşmak istiyorum.
Aynı zamanda bu konuda kendimi geliştirdikten sonra geri dönüp düşüncelerime tekrar bakmak istiyorum.
Aslında blog tutmamın en sevdiğim yanı da budur. Yazılım ile ilgili düşüncelerim sürekli değişmektedir.
Bu değişimi takip etmenin bir yolu da blog yazmaktır.&lt;/p&gt;

&lt;p&gt;Öncelikle yazılım yapmak demek sadece kod yazmak anlamına gelmez. Kod yazmak işin sadece bir kısmıdır.
Yazılımda testler de oldukça önemlidir. Çünkü yazdığınız kodların düzgün çalışıp çalışmadığını ancak testler ile anlayabilirsiniz.&lt;/p&gt;

&lt;p&gt;Başta ben herşeyin önceden yapıldığını ve kod yazmanın işin hep son aşaması olarak düşünürdüm.
Kendimi geliştirmek için yazmaya başladığım projelerde öncelikle detaylı bir tasarım yapardım.
İnşaat mühendislerinin yaptığı gibi yazılımı önce çizip tasarlayarak sonra kodlamaya geçerdim.
Tasarım prensiplerine hakim olmamamın da etkisi olsa da hep hesaplamadığım şeyler ortaya çıkıyordu.
Tasarımım da esnek olmadığı için projeyi kodlarken acayip rahatsızlık hissediyor ve bir sürü kötü kodlama yapıyordum.
Bu da beni olağanüstü mutsuz ediyordu. Birşeylerin eksik olduğunu farkettiğimde tasarım ile ilgili dökümanlar aramaya başlamıştım.
Bu sayede Özcan Acar ile tanışma fırsatı buldum. KurumsalJava blogunu incelediğimde Özcan Acar&amp;rsquo;ın test güdümlü geliştirmenin
çok önemli olduğunu yazılarında ve seminerlerinde gördüm. Sadece tasarım değil öğrenmem gereken bir sürü şey olduğunu farkettim.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;ui right floated bordered medium image content-image&#34; src=&#34;https://omerozkan.net/images/post/tdd/tdd_cycle.jpg&#34;
     alt=&#34;Test güdümlü geliştirme hayat döngüsü&#34; /&gt;
Birim testleri için Java da JUnit kullanılıyor. JUnit ile ilk Linux yaz kampında tanışmıştım.
Fakat orda test güdümlü yazılım yapmadık sadece yazdığımız kodları test ettik.
Test güdümlü yazılım geliştirmek demek sadece yazılan kodları test etmek anlamına gelmez.
Yazılımda niyetiniz önemlidir. Kodlamaya başlamadan önce testler yazılır.
Daha sonra bu testlerin çalışması için gereken kodlar yazılır. Bu sayede adım adım kodlama yapılmış olur.
Bu başlangıçta zaman kaybı gibi gözükebilir. Çünkü yazılımın gereken kodların yanı sıra bir de test yazmak zorundasınız.
Bazen iki yazılımcı aynı iş için çalışır. Bir yazılımcı testleri yazarken diğeri de testlerin çalışması için gereken kodları yazar.
Test yazmak başlangıçta zaman kaybı olarak görülebilir olsa da aslında durum tam tersidir.
Test yazdığınız zaman yazdığınız kodlar %100 test edilmiş olur. Bu sayede yaptığınız yazılım sorunsuz çalışır.
Otomatik çalışan testleriniz olmadığı zaman kodları test etmek bir hayli zordur.
Bu da zaman kaybettirir. Bunun yanı sıra gereksiz kodlar yazmanızı engeller. Bu sayede yine zaman kazanmış olursunuz.
Düşünün bir sınıfınız var ve o sınıfa refactoring uyguladınız veya optimizasyon yaptınız.
Yaptığınız değişikliklerin eskisi gibi düzgün çalıştığını nasıl anlarsınız? Bunun için testleri çalıştırmanız yeterli olacaktır.
Yazılımınız daha tutarlı bir hale gelmiş olacaktır. Özellikle refactoring yapmak için otomatik çalışan testlerinizin olması şarttır.&lt;/p&gt;

&lt;p&gt;Paul Graham&amp;rsquo;ın &amp;ldquo;Hackers and Painters&amp;rdquo; kitabından bir alıntı yapmak istiyorum:
&lt;em&gt;&amp;ldquo;Programlar yazılırken şekillendirilmelidir; tıpkı yazarlar, ressamlar ve mimarların yaptığı gibi.&amp;rdquo;&lt;/em&gt;.
Bu söze kesinlikle katılıyorum. Programları yazarken şekillendirmek için ise öncelikle amacımızın yani niyetimizin belirli olması gerekir.
Test güdümlü yazılım geliştirmek aynı zamanda bunu sağlamış olur.&lt;/p&gt;

&lt;p&gt;Test güdümlü yazılım ile ilgili bildiklerimi aktardıktan sonra bir örnek vermek istiyorum.
Çok sevdiğim bir kod katası olan Roman Rakamları katasından örnek vereceğim.
Dilerseniz &lt;a href=&#34;http://kodkata.com/roma-rakamlari-katasi/&#34;&gt;http://kodkata.com/roma-rakamlari-katasi/&lt;/a&gt; adresinden katayı izleyebilirsiniz.
Kata hakkında bilgi almak için ise &lt;a href=&#34;http://www.kurumsaljava.com/2012/04/07/kod-kata-ve-pratik-yapmanin-onemi/&#34; title=&#34;Kata&#34;&gt;buraya&lt;/a&gt; tıklayabilirsiniz.&lt;/p&gt;

&lt;p&gt;Öncelikle RomanNumeral sınıfı için test sınıfı (RomanNumeralTest) oluşturuyoruz ve bir test metodu yazıyoruz.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/bef51d116509da5f094d.js?file=romanNumeralTest1.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Anlaşılacağı gibi &amp;ldquo;I&amp;rdquo; değerini verdiğimde sonuç olarak 1 değerini döndermesi gerekir. Bunu için assertThat metodunu kullandım.
İlk parametre olarak test etmek istediğimiz metodu, ikinci parametre olarak beklediğimiz değeri giriyoruz.
Burda kodun okunmasını kolaylaştırmak amacı ile CoreMatchers.is ve CoreMatchers.equalTo  statik metodlarını kullandım.&lt;/p&gt;

&lt;p&gt;Henüz ortada RomanNumeral adlı sınıfımız yok. Öncelikle bu sınıfı oluşturup içerisine convert metodunu oluşturuyoruz.
Test kodlarını çalıştırdığımızda başarısız olduğunu görüyoruz. Bu testi geçmek için çok detaylı diğer roman rakamlarını da düşünerek kod yazmıyoruz.
Sadece bu testin gerçekleşmesi için gereken kodu yazıyoruz.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/bef51d11659da5f094d.js?file=romanNumeral1.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;code&gt;return 1&lt;/code&gt; ifadesini eklemek testlerin başarılı olmasını sağlayacaktır. Bunu gerçekleştirdikten sonra 2. bir test daha ekliyoruz.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/bef51d116509da5f094d.js?file=romanNumeralTest2.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;Burda dikkat ederseniz roman nesnesini yerel değişken olarak kullanmak yerine sınıf değişkeni yani &amp;ldquo;field&amp;rdquo; olarak kullanıyorum.
Çünkü aynı kodu her test için yazmak zorunda değiliz. Bu sayede DRY(Don&amp;rsquo;t Repeat Yourself) prensibine uymuş oluyoruz.
2. testimizde gördüğünüz gibi &amp;ldquo;V&amp;rdquo; değerini gönderdiğimizde 5 değerini almak istiyoruz.
Yukarda bahsettiğim gibi öncelikle niyetimizi yazıyoruz.
convert metodunda değişiklik yaparken bu sefer her 2 testin de çalışmasına dikkat etmemiz gerekiyor.
O yüzden RomanNumeral sınıfımız aşağıdaki gibi olacaktır.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/bef51d116509da5f094d.js?file=romanNumeral2.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;metodumuza bir if ekleyerek 2 testin de başarılı olmasını sağladık. Aynı şeyi &amp;ldquo;X&amp;rdquo; -&amp;gt; 10 için de yapıyoruz.&lt;/p&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/bef51d116509da5f094d.js?file=romanNumeralTest3.java&#34;&gt;&lt;/script&gt;

&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/bef51d116509da5f094d.js?file=romanNumeral3.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;3. testimizi yazıp gereken değişiklikleri yaptık. convert metoduna baktığımızda istenmeyen bir durum görüyoruz.
Her yeni test için sürekli bir &lt;code&gt;if&lt;/code&gt; ekleyemeyiz. O yüzden RomanNumeral sınıfını &lt;code&gt;Map&lt;/code&gt; kullanarak aşağıdaki şekilde düzenliyoruz.
Böylece metodu tek satıra düşürebiliriz.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;//gist.github.com/omerozkan/bef51d116509da5f094d.js?file=romanNumeral3Refactor.java&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Burada adım adım giderek refactoring işlemlerini de adım adım yaptık. Test güdümlü geliştirdiğimiz için testlerden
yola çıkarak geliştirdik. Katanın devamı için &lt;a href=&#34;http://kodkata.com/roma-rakamlari-katasi/&#34; title=&#34;Roman Rakamlari Katası&#34;&gt;video&lt;/a&gt;&amp;lsquo;yu izleyebilirsiniz..&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>